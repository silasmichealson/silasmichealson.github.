<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>A-Tune 服务配置与解释</title>
    <link href="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/"/>
    <url>/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Tune-服务配置与解释"><a href="#A-Tune-服务配置与解释" class="headerlink" title="A-Tune 服务配置与解释"></a>A-Tune 服务配置与解释</h1><h2 id="一-启动服务"><a href="#一-启动服务" class="headerlink" title="一.启动服务"></a>一.启动服务</h2><h3 id="1-配置网卡及磁盘"><a href="#1-配置网卡及磁盘" class="headerlink" title="1.配置网卡及磁盘"></a>1.配置网卡及磁盘</h3><p>在安装时使用下指令安装则将检测的磁盘和网卡写入&#x2F;etc&#x2F;atuned&#x2F;atuned.cnf文件中,可以在文件中修改disk和network选指定的磁盘和网卡</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">make collector-<span class="hljs-keyword">install</span><br>make <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A1.jpg"></p><h3 id="2-启动A-Tune服务"><a href="#2-启动A-Tune服务" class="headerlink" title="2.启动A-Tune服务"></a>2.启动A-Tune服务</h3><p>使用指令</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl daemon-reload<br>sudo <span class="hljs-params">system</span>ctl start atuned<br>sudo <span class="hljs-params">system</span>ctl start atune-engine<br></code></pre></td></tr></table></figure><p>查看atuned或者atuned-engine服务状态</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">sudo systemctl <span class="hljs-keyword">status</span> atuned<br>sudo systemctl <span class="hljs-keyword">status</span> atune-engine<br></code></pre></td></tr></table></figure><p><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A2.jpg"><br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A3.jpg"></p><h3 id="3-atune-adm-命令"><a href="#3-atune-adm-命令" class="headerlink" title="3.atune-adm 命令"></a>3.atune-adm 命令</h3><p><code>atune-adm list</code>列出系统支持的profile以及当前已激活的profile</p><p> <img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A4.jpg"></p><p><code>atune-adm profile [name]</code>激活对应策略</p><p><code>atune-adm analysis [options]</code>在线静态调优,实时采集系统信息进行负载类型识别并自动优化</p><p><code>atune-adm tuning [OPTIONS] &lt;PROJECT_YAML&gt;</code>离线动态调优,使用指定项目文件对所选参数进行动态空间的搜索找到当前环境配置下的最优解。</p><h2 id="二-离线动态调优测例"><a href="#二-离线动态调优测例" class="headerlink" title="二.离线动态调优测例"></a>二.离线动态调优测例</h2><blockquote><p>以A-Tune&#x2F;examples&#x2F;tuning目录中对gcc编译器的优化为例。</p></blockquote><h3 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1.准备环境"></a>1.准备环境</h3><p><code>sh prepare.sh</code><br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A5.jpg"></p><h3 id="2-下载stream-c-内存带宽测试程序"><a href="#2-下载stream-c-内存带宽测试程序" class="headerlink" title="2.下载stream.c 内存带宽测试程序"></a>2.下载stream.c 内存带宽测试程序</h3><p><code>wget http://www.cs.virginia.edu/stream/FTP/Code/stream.c</code></p><h3 id="3-调优"><a href="#3-调优" class="headerlink" title="3.调优"></a>3.调优</h3><p><code>atune-adm tuning --project gcc_compile --detail gcc_compile_client.yaml</code><br>结果<br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A6.jpg"><br>内存带宽提升121%，编译后的可以执行文件大小减小17%。</p><h3 id="4-保存结果"><a href="#4-保存结果" class="headerlink" title="4.保存结果"></a>4.保存结果</h3><p><code>atune-adm tuning --restore --project gcc_compile</code></p><h2 id="三-A-Tune离线调优应用"><a href="#三-A-Tune离线调优应用" class="headerlink" title="三.A-Tune离线调优应用"></a>三.A-Tune离线调优应用</h2><p>&amp;emsp;&amp;emsp;离线动态调优包含三个输入文件：client.yaml、server.yaml和benchmark。</p><ul><li>client.yaml: 存放在客户端的文件，包含调优的评价指标等信息。</li><li>server.yaml: 存放在服务端的文件，包含调优的可调节参数等信息。</li><li>benchmark: 存放在客户端的文件，通过运行该文件以获取评价指标的具体数值。<br>这里以gcc离线动态调优为例，说明这三个文件。<br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A7.jpg"></li></ul><h3 id="1-client-yaml"><a href="#1-client-yaml" class="headerlink" title="1.client.yaml"></a>1.client.yaml</h3><p>其中包含：</p><blockquote><p>调优算法选择(line 2)<br>迭代次数(line 3)<br>随机迭代次数(line 4)<br>benchmark执行命令(line 6)<br>评价指标1相关信息(line 8 - 13)<br>评价指标2相关信息(line 14 - end)<br>另外，还可以在client.yaml中添加参数选择：</p></blockquote><p>参数选择是在进行离线动态调优前执行的步骤，其目的是在进行离线动态调优前缩减参数空间，在给出的参数空间中选择出对性能影响最大的参数并进行调优。</p><p>实现方法是在client.yaml中添加如下参数：</p><blockquote><p>feature_filter_engine: 参数选择算法<br>feature_filter_cycle: 参数选择轮数<br>feature_filter_iters: 参数选择的迭代次数<br>feature_filter_count: 每轮选择出的参数<br>split_count: 调优参数取值范围中均匀选取的参数个数</p></blockquote><h3 id="2-server-yaml"><a href="#2-server-yaml" class="headerlink" title="2.server.yaml"></a>2.server.yaml</h3><p><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A8.jpg"><br>应用启动命令(line 3)<br>应用停止命令(line 4)<br>可调参数等内容(line 5 - end)</p><h3 id="3-benchmark文件"><a href="#3-benchmark文件" class="headerlink" title="3.benchmark文件"></a>3.benchmark文件</h3><p><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A9.jpg"><br>benchmark文件用于在调优执行时，会根据client.yaml中提供的命令执行此文件。  </p><p>执行优化并保存结果<br>执行优化：<br><code>atune-adm tuning --project &lt;PROJECT_NAME&gt; --detail &lt;client.yaml&gt;</code></p><p>保存结果：<br><code>atune-adm tuning --restore --project &lt;PROJECT_NAME&gt;</code></p><h2 id="四-A-Tune使用"><a href="#四-A-Tune使用" class="headerlink" title="四.A-Tune使用"></a>四.A-Tune使用</h2><h3 id="1-总体说明"><a href="#1-总体说明" class="headerlink" title="1.总体说明"></a>1.总体说明</h3><p><code>atune-adm</code>支持的命令可以通过 <code>atune-adm help/--help/-h</code> 查询。</p><p>使用方法中所有命令的使用举例都是在单机部署模式下，如果是在分布式部署模式下，需要指定服务器IP和端口号，例如：</p><p><code>atune-adm -a 192.168.3.196 -p 60001 list</code><br>define、update、undefine、collection、train、upgrade不支持远程执行。</p><h3 id="2-查询负载类型"><a href="#2-查询负载类型" class="headerlink" title="2.查询负载类型"></a>2.查询负载类型</h3><p>list：查询系统当前支持的profile，以及当前处于active状态的profile。</p><p><code>atune-adm list </code></p><h3 id="3-分析负载类型并自优化"><a href="#3-分析负载类型并自优化" class="headerlink" title="3.分析负载类型并自优化"></a>3.分析负载类型并自优化</h3><p>使用默认的模型进行应用识别，不进行自动优化</p><p><code>atune-adm analysis --characterization</code><br>使用默认的模型进行应用识别，并进行自动优化</p><p><code>atune-adm analysis</code><br>使用自训练的模型进行应用识别</p><p><code>atune-adm analysis --model /usr/libexec/atuned/analysis/models/new-model.m</code></p><h3 id="4-自定义模型"><a href="#4-自定义模型" class="headerlink" title="4.自定义模型"></a>4.自定义模型</h3><p>A-Tune支持用户定义并学习新模型。定义新模型的操作流程如下：</p><p>​- 步骤 1 用define命令定义一个新应用的profile</p><p>​- 步骤 2 用collection命令收集应用对应的系统数据</p><p>​- 步骤 3 用train命令训练得到模型</p><h4 id="4-1-define"><a href="#4-1-define" class="headerlink" title="4.1 define"></a>4.1 define</h4><p>功能描述</p><p>添加用户自定义的应用场景，及对应的profile优化项。</p><p>命令格式</p><p><code>atune-adm define &lt;service_type&gt; &lt;application_name&gt; &lt;scenario_name&gt;&lt;profile_path&gt;</code><br>使用示例</p><p>新增一个profile，service_type的名称为test_service，application_name的名称为test_app，scenario_name的名称为test_scenario，优化项的配置文件为example.conf。</p><p><code>atune-adm define test_service test_app test_scenario ./example.conf</code></p><h4 id="4-2-collection"><a href="#4-2-collection" class="headerlink" title="4.2 collection"></a>4.2 collection</h4><p>功能描述</p><p>采集业务运行时系统的全局资源使用情况以及OS的各项状态信息，并将收集的结果保存到csv格式的输出文件中，作为模型训练的输入数据集。</p><p>命令格式</p><p><code>atune-adm collection &lt;OPTINOS*&gt;*</code><br>使用示例</p><p><code>atune-adm collection --filename name --interval 5 --duration 1200 --output_path /home/data --disk sda --network eth0 --app_type test_type </code></p><h4 id="4-3-train"><a href="#4-3-train" class="headerlink" title="4.3 train"></a>4.3 train</h4><p>功能描述</p><p>使用采集的数据进行模型的训练。训练时至少采集两种应用类型的数据，否则训练会出错。</p><p>命令格式</p><p><code>atune-adm train &lt;OPTINOS*&gt;*</code><br>使用示例</p><p>使用data目录下csv文件作为训练输入，生成的新模型new-model.m存在model目录下。</p><p><code>atune-adm train --data_path /home/data --output_file /usr/libexec/atuned/analysis/models/new-model.m </code></p><h4 id="4-4-undefine"><a href="#4-4-undefine" class="headerlink" title="4.4 undefine"></a>4.4 undefine</h4><p>功能描述</p><p>删除用户自定义的profile。</p><p>命令格式</p><p><code>atune-adm undefine &lt;profile*&gt;*</code><br>使用示例</p><p>删除自定义的profile。</p><p><code>atune-adm undefine test_service-test_app-test_scenario</code></p><h3 id="5-Profile相关操作"><a href="#5-Profile相关操作" class="headerlink" title="5. Profile相关操作"></a>5. Profile相关操作</h3><h4 id="5-1-查询profile"><a href="#5-1-查询profile" class="headerlink" title="5.1 查询profile"></a>5.1 查询profile</h4><p>功能描述</p><p>查看对应的profile内容。</p><p>命令格式</p><p><code>atune-adm info &lt;profile*&gt;*</code><br>使用示例</p><p>查看web-nginx-http-long-connection的profile内容：</p><p><code>atune-adm info web-nginx-http-long-connection</code></p><h4 id="5-2-更新profile"><a href="#5-2-更新profile" class="headerlink" title="5.2 更新profile"></a>5.2 更新profile</h4><p>功能描述</p><p>将已有profile中原来的优化项更新为new.conf中的内容。</p><p>命令格式</p><p><code>atune-adm update &lt;profile*&gt;* &lt;profile_path*&gt;*</code><br>使用示例</p><p>更新名为test_service-test_app-test_scenario的profile优化项为new.conf。</p><p><code>atune-adm update test_service-test_app-test_scenario ./new.conf</code></p><h4 id="5-3-激活profile"><a href="#5-3-激活profile" class="headerlink" title="5.3 激活profile"></a>5.3 激活profile</h4><p>功能描述:</p><p>手动激活profile，使其处于active状态。</p><p>命令格式</p><p><code>atune-adm profile &lt;profile&gt;</code><br>使用示例</p><p>激活web-nginx-http-long-connection对应的profile配置。</p><p><code>atune-adm profile web-nginx-http-long-connection</code></p><h4 id="5-4-回滚profile"><a href="#5-4-回滚profile" class="headerlink" title="5.4 回滚profile"></a>5.4 回滚profile</h4><p>功能描述:</p><p>回退当前的配置到系统的初始配置。</p><p>命令格式</p><p><code>atune-adm rollback</code><br>使用示例</p><p><code>atune-adm rollback</code></p><h3 id="6-更新数据库"><a href="#6-更新数据库" class="headerlink" title="6. 更新数据库"></a>6. 更新数据库</h3><p>功能描述</p><p>更新系统的数据库。</p><p>命令格式</p><p><code>atune-adm upgrade &lt;DB_FILE&gt;</code><br>使用示例</p><p>数据库更新为new_sqlite.db。</p><p><code>atune-adm upgrade ./new_sqlite.db</code></p><h3 id="7-系统信息查询"><a href="#7-系统信息查询" class="headerlink" title="7. 系统信息查询"></a>7. 系统信息查询</h3><p>功能描述</p><p>检查系统当前的cpu、bios、os、网卡等信息。</p><p>命令格式</p><p><code>atune-adm check</code><br>使用示例</p><p><code>atune-adm check </code></p><h3 id="8-参数自调优"><a href="#8-参数自调优" class="headerlink" title="8.参数自调优"></a>8.参数自调优</h3><p>功能描述</p><p>使用指定的项目文件对参数进行动态空间的搜索，找到当前环境配置下的最优解。</p><p>命令格式</p><p><code>atune-adm tuning [OPTIONS] &lt;PROJECT_YAML&gt;</code><br>在运行命令前，确保以下条件已经满足：</p><p>服务端的yaml配置文件已经编辑完成并放置于 atuned服务下的<br>**&#x2F;etc&#x2F;atuned&#x2F;tuning&#x2F;**目录中</p><p>客户端的yaml配置文件已经编辑完成并放置于atuned客户端任意目录下</p><p>使用示例</p><p>进行tuning调优</p><p><code>atune-adm tuning --project compress --detail compress_client.yaml</code><br>恢复tuning调优前的初始配置，compress为yaml文件中的项目名称</p><p><code>atune-adm tuning --restore --project compress</code></p><h2 id="五-A-Tune实战"><a href="#五-A-Tune实战" class="headerlink" title="五. A-Tune实战"></a>五. A-Tune实战</h2><h3 id="1-通过A-Tune优化压缩算法配置"><a href="#1-通过A-Tune优化压缩算法配置" class="headerlink" title="1.通过A-Tune优化压缩算法配置"></a>1.通过A-Tune优化压缩算法配置</h3><p>执行以下命令进入压缩文件样本目录：</p><p><code>cd ~/A-Tune/examples/tuning/compress/</code><br>获取测试用例：</p><p><code>wget http://cs.fit.edu/~mmahoney/compression/enwik8.zip</code><br>执行如下命令，使用prepare.sh脚本解压缩enwik8.zip文件并进行一些参数设置，例如compress_client.yaml文件中time的权重为20，compress_ratio的权重为80，表明本次优化目标偏重压缩率：</p><p><code>sh prepare.sh enwik8.zip</code><br>运行结果如下图所示：<br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A10.jpg"><br>说明：使用prepare.sh脚本对enwik8.zip文件进行解压缩完毕，当前目录应存在6个文件及一个文件夹，各文件的功能注解如下：</p><ol><li><p>enwik8.zip为压缩文件样本，</p></li><li><p>enwik8为enwik8.zip文件解压后的文件夹，</p></li><li><p>prepare.sh为执行调优前的必要准备工作，具体信息可以通过vim命令进入查看，</p></li><li><p>compress.py为本次调优的基准。compress.py文件通过bz2、zlib、gzip中的一种方式对enwik8文件进行压缩。compress.py文件的执行时间将作为调优的评价指标之一，即compress.py文件执行时间越短，调优效果越好，</p></li><li><p>compress_client.yaml文件记录本次调优的评价指标，有time和compress_ratio两个评价指标，</p></li><li><p>compress_server.yaml文件记录本次调优的可调节项，有compressLevel和compressMethod两个可调节项。</p></li></ol><p>执行以下命令进行查看：<br><code>ls -la</code><br>文件列表如下图所示：<br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A11.jpg"><br>继续执行以下命令，查看压缩算法的基线性能：</p><p><code>python3 compress.py</code><br>查看压缩算法的基线性能输出结果，如下图所示：<br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A12.jpg"><br>说明：通过压缩时间和压缩比例两个维度来衡量，图中时间花费4.6s左右，压缩后文件体积缩小2.7倍左右。后续步骤会对压缩算法进行调优，目标是降低时间花费，并增大压缩前后文件大小的比例。</p><p><strong>注意：压缩算法的基线性能可能会因为具体的运行环境而有所不同。</strong></p><p>执行以下命令对compress.py文件进行备份：<br><code>cp compress.py&#123;,.bak&#125;</code><br>说明：在进行调优时，compress.py文件中的COMPRESS_LEVEL和COMPRESS_METHOD两个值(12、13行)将会作为可调节项发生变更，因此在调节前备份此文件，有利于进行调优后与调优前的参数对比。</p><p>执行以下命令(约【2分钟】)，进行调优以找到最优配置：</p><p><code>atune-adm tuning --project compress --detail compress_client.yaml</code><br>最终结果如下图所示，其中1为调优性能及参数，2为基线性能：<br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A13.jpg"><br> 以上调优结果反映在了参数compressLevel和compressMethod的设置上，执行以下命令对比调优前后的compress.py文件：</p><p>注意：对比结果可能会因为具体的运行环境而有所不同。</p><p><code>diff compress.py compress.py.bak</code><br>对比结果如下图所示，图中可看到调优前后compressLevel的值有所区别，调优前compressLevel的值为1，调优后则为6，说明本次性能调优通过改变compressLevel的值提高了压缩算法的性能：<br><img src="/2022/05/09/A-Tune%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%A7%A3%E9%87%8A/A14.jpg"></p><p> 说明：执行调优时的各项参数解释如下：</p><ol><li>评价指标，存于compress_client.yaml文件中，通过评价指标可以直观的看出性能优劣。</li></ol><ul><li><p>time：enwik8文件夹压缩时间，时间越短则性能越好；</p></li><li><p>compress_ratio：enwik8文件夹压缩前后的size大小，比例越大则压缩后文件占内存空间越小，说明压缩效果越好。</p></li></ul><ol start="2"><li>可调节项，存于compress_server.yaml文件中，单看可调节项的变化无法判断性能优劣，而是在每次修改可调节项后查看评价指标，基于评价指标的变化判断性能有无增长。</li></ol><ul><li><p>compressLevel：压缩等级，是调优的可调节项之一，本次调优共设九个等级，对应数值1~9；</p></li><li><p>compressMethod——压缩方式，是调优的可调节项之一，本次调优共设三种压缩方式，分别为bz2、zlib、gzip。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
      <category>A-Tune</category>
      
    </categories>
    
    
    <tags>
      
      <tag>A-Tune</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP权威指南-读书笔记-第一部分</title>
    <link href="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <url>/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP权威指南-–-读书笔记-–-第一部分"><a href="#HTTP权威指南-–-读书笔记-–-第一部分" class="headerlink" title="HTTP权威指南 – 读书笔记 – 第一部分"></a>HTTP权威指南 – 读书笔记 – 第一部分</h1><h2 id="第一部分-HTTP-Web的基础"><a href="#第一部分-HTTP-Web的基础" class="headerlink" title="第一部分 HTTP:Web的基础"></a>第一部分 HTTP:Web的基础</h2><h3 id="第一章-HTTP概述"><a href="#第一章-HTTP概述" class="headerlink" title="第一章 HTTP概述"></a>第一章 HTTP概述</h3><h4 id="1-Web-http-服务器与客户端"><a href="#1-Web-http-服务器与客户端" class="headerlink" title="1.Web(http)服务器与客户端"></a>1.Web(http)服务器与客户端</h4><p><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h1.jpg"><br>&amp;emsp;&amp;emsp;可能你每天都在使用 HTTP 客户端。最常见的客户端就是Web浏览器， 比如微软的Internet Explorer。Web浏览器向服务器请求HTTP对象，并将这些对象显示在你的屏幕上。<br>&amp;emsp;&amp;emsp;浏览一个页面时,浏览器会向服务器<a href="http://www.oreilly.com发送一条http请求.服务器会去寻找所期望的对象(在这个例子中就是/">www.oreilly.com发送一条HTTP请求。服务器会去寻找所期望的对象（在这个例子中就是</a> &#x2F;index.html，如果成功，就将对象、对象类型、对象长度以及其他一些信息放在 HTTP 响应中发送给客户端</p><h4 id="2-资源"><a href="#2-资源" class="headerlink" title="2.资源"></a>2.资源</h4><p>&amp;emsp;&amp;emsp;<strong>注意:一切能提供web内容的东西都是web资源</strong>包括:图片文件,文本文件,摄像头网关,搜索引擎网关等.</p><ul><li>http对全部通过web传输的对象都带上MIME(mime.type)类型的数据格式标签,标记类型</li></ul><p><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h2.jpg"></p><blockquote><p><strong>URI(统一资源标识符) 包含两类 URL(统一资源定位符) 以及 URN(统一资源名)</strong></p></blockquote><p><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h3.jpg"></p><ul><li>URL的第一部分被称为方案(scheme),说明了访问资源所使用的协议类型。这部分通常就是HTTP协议(http:&#x2F;&#x2F;)。</li><li>第二部分给出了服务器的因特网地址（比如，<a href="http://www.joes-hardware.com)./">www.joes-hardware.com)。</a></li><li>其余部分指定了Web服务器上的某个资源（比如，&#x2F;specials&#x2F;,saw-blade.gif)。<br>现在，几乎所有的URI都是URL。</li></ul><p>URN作为特定内容的唯一名称使用,与目前的资源所在地无关,在试验阶段并未大范围使用.无特殊说明,资源定位使用URL</p><h4 id="3-事务"><a href="#3-事务" class="headerlink" title="3.事务"></a>3.事务</h4><p>&amp;emsp;&amp;emsp;一个 HTTP 事务由一条(从客户端发往服务器的)请求命令和一个(从服务器发回客户端的)响应结果组成。这种通信是通过名HTTP 报文（HTTPmessage）的格式化数据块进行的<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h4.jpg"></p><p><strong>3.1 方法</strong><br>&amp;emsp;&amp;emsp;HTTP 支持几种不同的请求命令，这些命令被称为HTTP方法（HTTP method).每条 HTTP 请求报文都包含一个方法。 这个方法会告诉服务器要执行什么动作.</p><table><thead><tr><th>http方法</th><th>动作</th></tr></thead><tbody><tr><td>GET</td><td>从服务器向刻划断发送命名资源</td></tr><tr><td>PUT</td><td>将来自客户端的数据存储到一个命名的服务器资源中去</td></tr><tr><td>DELETE</td><td>从服务器删除命名资源</td></tr><tr><td>POST</td><td>将客户端数据发送到一个服务器网关应用软件</td></tr><tr><td>HEAD</td><td>仅发送命名资源相应中的http首部</td></tr></tbody></table><p><strong>3.2 状态码</strong></p><p>&amp;emsp; &amp;emsp; 每条 HTTP 响应报文返回时都会携带一个状态码。 状态码是一个三位数字的代码，告知客户端请求是否成功， 或者是否需要采取其他动作。</p><table><thead><tr><th>常见HTTP状态码</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>ok,文档正确返回</td></tr><tr><td>302</td><td>重定向(Redirect)</td></tr><tr><td>404</td><td>Not Found 无法找到资源</td></tr></tbody></table><blockquote><p><strong>注意:web页面可以包含多个对象,一般的web页面是一组资源的集合,并且对每一个嵌入式资源使用一个单独的http事务</strong></p></blockquote><h4 id="4-报文"><a href="#4-报文" class="headerlink" title="4.报文"></a>4.报文</h4><p>&amp;emsp;&amp;emsp;从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request_message）。从服务器发往客户端的报文称为响应报文（response message），此外没有其他类型的HTTP 报文。 HTTP 请求和响应报文的格式很类似。<br>HTTP 报文包括以下三个部分。</p><ul><li>起始行<br>报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。</li><li>首部字段<br>起始行后面有零个或多个首部字段。 每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。 添加一个首部字段和添加新行一样简单。</li><li>主体<br>空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据； 响应主体中装载了要返回给客户端的数据。 起始行和首部都是文本形式且都是结构化的，而主体则不同， 主体中可以包含任意的二进制数据（ 比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h5.jpg"></li></ul><h4 id="5-连接"><a href="#5-连接" class="headerlink" title="5.连接"></a>5.连接</h4><p>&amp;emsp;&amp;emsp;HTTP 是个应用层协议。HTTP无需操心网络通信的具体细节；它把联网的细节都交给了通用、可靠的因特网传输协议TCP&#x2F;IP。<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h6.jpg"><br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h7.jpg"></p><ol><li>浏览器从 URL 中解析出服务器的主机名；</li><li>浏览器将服务器的主机名转换成服务器的 IP 地址；</li><li>浏览器将端口号（如果有的话） 从URL中解析出来；</li><li>浏览器建立一条与 Web 服务器的 TCP 连接；</li><li>浏览器向服务器发送一条 HTTP 请求报文；</li><li>服务器向浏览器回送一条 HTTP 响应报文；</li><li>关闭连接， 浏览器显示文档。</li></ol><h4 id="6-Telnet模拟web客户端"><a href="#6-Telnet模拟web客户端" class="headerlink" title="6.Telnet模拟web客户端"></a>6.Telnet模拟web客户端</h4><p>&amp;emsp;&amp;emsp;Telnet 程序可以将键盘连接到某个目标 TCP 端口，并将此TCP端口的输出回送到显示屏上。Telnet 常用于远程终端会话， 但它几乎可以连接所有的 TCP 服务器，包括 HTTP 服务器。<br>&amp;emsp;&amp;emsp;可以通过 Telnet 程序直接与 Web 服务器进行对话。通过 Telnet 可以打开一条到某台机器上某个端口的 TCP 连接，然后直接向那个端口输入一些字符。 Web 服务器会将 Telnet 程序作为一个 Web 客户端来处理，所有回送给 TCP 连接的数据都会显示在屏幕上。</p><p>【问题】: http 版本的区别? 1.0,2.0,3.0?</p><h4 id="7-web组件"><a href="#7-web组件" class="headerlink" title="7.web组件"></a>7.web组件</h4><ul><li>代理<br>位于客户端和服务器之间的HTTP中间实体。<br>出于安全考虑，通常会将代理作为转发所有Web流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。</li><li>缓存<br>HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方。<br>Web缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP代理服务器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了.<br>客户端从附近的缓存下载文档会比从远程Web服务器下载快得多。HTTP定义了很多功能，使得缓存更加高效，并规范了文档的新鲜度和缓存内容的隐私性。</li><li>网关<br>连接其他应用程序的特殊 Web 服务器。<br>网关（ gateway） 是一种特殊的服务器， 作为其他服务器的中间实体使用。 <strong>通常用于将 HTTP 流量转换成其他的协议。</strong> 网关接受请求时就好像自己是资源的源端服务器一样。 客户端可能并不知道自己正在与一个网关进行通信</li><li>隧道<br>对 HTTP 通信报文进行盲转发的特殊代理。<br>隧道（ tunnel） 是建立起来之后， 就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序。 HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据， 转发时不会窥探数据。<br>HTTP 隧道的一种常见用途是通过 HTTP 连接承载加密的安全套接字层（ SSL，Secure Sockets Layer） 流量， 这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。  HTTP&#x2F;SSL 隧道收到一条 HTTP 请求， 要求建立一条到目的地址和端口的输出连接， 然后在 HTTP 信道上通过隧道传输加密的 SSL 流量， 这样就可以将其盲转发到目的服务器上去了。</li><li>Agent 代理<br>发起自动 HTTP 请求的半智能 Web 客户端<br>用户 Agent 代理（ 或者简称为 Agent 代理） 是代表用户发起 HTTP 请求的客户端程序。 所有发布 Web 请求的应用程序都是 HTTP Agent 代理。到目前为止， 我们只提到过一种 HTTP Agent 代理： Web 浏览器， 但用户 Agent 代理还有很多其他类型</li></ul><p>2022&#x2F;4&#x2F;30 22:27:36 </p><h3 id="第二章-URL与资源"><a href="#第二章-URL与资源" class="headerlink" title="第二章 URL与资源"></a>第二章 URL与资源</h3><h4 id="2-1-互联网资源"><a href="#2-1-互联网资源" class="headerlink" title="2.1 互联网资源"></a>2.1 互联网资源</h4><p>&amp;emsp;&amp;emsp;URL的第一分(http)是URL方案(scheme)。方案可以告知Web客户端怎样访问资源。在这个例子中，URL说明要使用HTTP协议。<br>&amp;emsp;&amp;emsp;URL的第二部分（<a href="http://www.joes-hardware.com)指的是服务器的位置.这部分告知web客户端资源位于何处./">www.joes-hardware.com)指的是服务器的位置。这部分告知Web客户端资源位于何处。</a><br>&amp;emsp;&amp;emsp;URL的第三部分(&#x2F;seasonal&#x2F;index-fall.html)是资源路径。路径说明了请求的是服务器上哪个特定的本地资源。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">URL 方案:<span class="hljs-regexp">//</span>服务器位置/路径<br>例 ftp:<span class="hljs-regexp">//</span>ftp.lots-o-books.com<span class="hljs-regexp">/pub/</span>complete-price-list.xls <br>使用文件传输协议ftp获取文件;<br>服务器ftp.lots-o-books.com域名;<br>路径<span class="hljs-regexp">/pub/</span>complete-price-list.xls<br></code></pre></td></tr></table></figure><h4 id="2-2-URL语法"><a href="#2-2-URL语法" class="headerlink" title="2.2 URL语法"></a>2.2 URL语法</h4><p><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></p><table><thead><tr><th>组件</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>方案(scheme)</td><td>访问服务器以获取资源时要使用哪种协议</td><td>无</td></tr><tr><td>用户</td><td></td><td>某些方案访问资源时需要的用户名</td></tr><tr><td>密码</td><td>用户名后面可能要包含的密码，中间由冒号(:)</td><td>&lt;E-mail地址&gt;</td></tr><tr><td>主机</td><td>分隔资源宿主服务器的主机名或点分P地址</td><td>无</td></tr><tr><td>端口</td><td>资源宿主服务器正在监听的端口号。很多方案都有默认端口号(HTTP的默认端口号为80)</td><td>方案特有</td></tr><tr><td>路径</td><td>服务器上资源的本地名，由一个斜杠(&#x2F;)将其与前面的URL组件分隔开来。路径组件的语法是与服务器和方案有关的（URL路径可以分为若干个段，每段都可以有其特有的组件。)</td><td>无</td></tr><tr><td>参数</td><td>某些方案会用这个组件来指定输入参数。参数为名&#x2F;值对。URL中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号(：)分隔</td><td>无</td></tr><tr><td>查询</td><td>某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引攀以及其他因特网关)。查询组件的内容没有通用格式。用字符“？”将其与URL的其余部分分隔开来</td><td>无</td></tr><tr><td>片段</td><td>一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器，这个字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来</td><td>无</td></tr></tbody></table><p><strong>下面以 <a href="http://www.baidu.com/index.html">http://www.baidu.com:80/index.html</a> 为例介绍</strong><br>方案:http 主机为:<a href="http://www.baidu.com/">www.baidu.com</a> 端口:80 路径:&#x2F;index.html</p><ul><li><p>方案(scheme) 使用什么协议<br>&amp;emsp;&amp;emsp;实际上是规定如何访问指定资源的主要标识符，它会告诉负责解析URL的应用程序应该使用什么协议。方案组件必须以一个字母符号开始，由第一个“：”符号将其与URL的其余部分分隔开来。方案名是大小写无关的，例<a href="http://www.baidu.com/index.html">http://www.baidu.com:80/index.html</a> 使用 http协议 </p></li><li><p>主机与端口<br>&amp;emsp;&amp;emsp;要想在因特网上找到资源，应用程序要知道是哪台机器装载了资源，以及在那台机器的什么地方可以找到能对目标资源进行访问的服务器。URL的主机和端口组件提供了这两组信息。<br>&amp;emsp;&amp;emsp;主机组件标识了因特网上能够访问资源的宿主机器。可以用上述主机(<a href="http://www.baidu.com),或者ip地址(14.215.177.39)来表示主机名.比如,下面两个url就指向同一个资源一第一个url是通过主机名,第二个是通过ip地址指向服务器的/">www.baidu.com),或者IP地址(14.215.177.39)来表示主机名。比如，下面两个URL就指向同一个资源一第一个URL是通过主机名，第二个是通过IP地址指向服务器的</a></p></li><li><p>用户名和密码<br>&amp;emsp;&amp;emsp;很多服务器都要求输人用户名和密码才会允许用户访问数据。FTP服务器就是这样一个常见的实例。这里有几个例子：<br><a href="ftp://ftp.prep.ai.mit.edu/pub/gnu">ftp://ftp.prep.ai.mit.edu/pub/gnu</a><br><a href="ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu">ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu</a><br><a href="ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu">ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu</a><br><a href="http://joe:joespasswd@www.joes-hardware.com/sales_info.txt">http://joe:joespasswd@www.joes-hardware.com/sales_info.txt</a></p></li><li><p>第一个例子没有用户或密码组件，只有标准的方案、主机和路径。如果某应用程序使用的URL方案要求输入用户名和密码，比如FTP,但用户没有提供，它通常会插入一个默认的用户名和密码。比如，如果向浏览器提供一个FTP URL,但没有指定用户名和密码，它就会插入anonymous(匿名用户)作为你的用户名，并发送一个默认的密码(Internet Explorer会发送IEUser,Netscape Navigator则会发送mozilla)。</p></li><li><p>第二个例子显示了一个指定为anonymous的用户名。这个用户名与主机组件组合在一起，看起来就像E-mail地址一样。字符“@”将用户和密码组件与URL的其余部分分隔开来。</p></li><li><p>第三个例子中，指定了用户名(anonymous)和密码(my_passwd),两者之间由字符“：”分隔。</p></li><li><p>路径<br>&amp;emsp;&amp;emsp;URL的路径组件说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。比如：<a href="http://www.joes-hardware.com/seasonal/index-fall.html">http://www.joes-hardware.com:80/seasonal/index-fall.html</a> 这个URL中的路径为&#x2F;seasonal&#x2F;index-fall.html,很像UNIX文件系统中的文件系统路径。路径是服务器定位资源时所需的信息。可以用字符“”将HTTP URL的路径组件划分成一些路径段(path segment)(还是与UNIX文件系统中的文件路径类似)。每个路径段都有自己的参数(param)组件。</p></li><li><p>参数<br>&amp;emsp;&amp;emsp;对很多方案来说，只有简单的主机名和到达对象的路径是不够的。除了服务器正在监听的端口，以及是否能够通过用户名和密码访问资源外，很多协议都还需要更多的信息才能工作。负责解析URL的应用程序需要这些协议参数来访问资源。否则，另一端的服务器可能就不会为请求提供服务，或者更糟糕的是，提供错误的服务。比如，像FTP这样的协议，有两种传输模式，二进制和文本形式。你肯定不希望以文本形式来传送二进制图片，这样的话，二进制图片可能会变得一团糟。<br>&amp;emsp;&amp;emsp;为了向应用程序提供它们所需的输入参数，以便正确地与服务器进行交互，URL中有一个参数组件。这个组件就是URL中的名值对列表，由字符“；”将其与URL的其余部分（以及各名值对）分隔开来。它们为应用程序提供了访问资源所需的所有附加信息。比如：<br><a href="ftp://prep.ai.mit.edu/pub/gnu;type=d">ftp://prep.ai.mit.edu/pub/gnu;type=d</a><br>在这个例子中，有一个参数type&#x3D;d,参数名为type,值为d。如前所述，HTTP URL的路径组件可以分成若干路径段。每段都可以有自己的参数。比如：<br><a href="http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true">http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true</a><br>这个例子就有两个路径段，hammers和index.html。hammers路径段有参数sale,其值为false。index.html段有参数graphics,其值为true。</p></li></ul><p>查询与片段在此处略过</p><h4 id="2-3-URL快捷方式"><a href="#2-3-URL快捷方式" class="headerlink" title="2.3 URL快捷方式"></a>2.3 URL快捷方式</h4><ul><li>2.3.1 相对UPL</li></ul><p>&amp;emsp;&amp;emsp;URL有两种方式：绝对的和相对的。到目前为止，我们只见过绝对URL。绝对URL中包含有访问资源所需的全部信息。另一方面，相对URL是不完整的。要从相对URL中获取访问资源所需的全部信息，就必须相对于另一个，被称为其基础(base)的URL进行解析。相对URL是URL的一种便捷缩略记法。<br>&amp;emsp;&amp;emsp;相对URL只是URL的片段或一小部分。处理URL的应用程序（比如浏览器）要能够在相对和绝对URL之间进行转换。<br>还需要注意的是，相对URL为保持一组资源（比如一些HTML页面）的便携性提供了一种便捷方式。如果使用的是相对URL,就可以在搬移一组文档的同时，仍然保持链接的有效性，因为相对UL都是相对于新基础进行解释的。这样就可以实现在其他服务器上提供镜像内容之类的功能了。</p><blockquote><p><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h8.jpg"></p></blockquote><ol><li>基础URL<br>&amp;emsp;&amp;emsp;转换处理的第一步就是找到基础URL。基础URL是作为相对URL的参考点使用的。可以来自以下几个不同的地方。</li></ol><ul><li>在资源中显式提供<br>有些资源会显式地指定基础URL。比如，HTML文档中可能会包含一个定义了<br>基础URL的HTML标记<BASE>,通过它来转换那个HTML文档中的所有相对URL。</li><li>封装资源的基础URL<br>如果在一个没有显式指定基础URL的资源中发现了一个相对URL，可以将它所属资源的URL作为基础。</li><li>没有基础URL<br>在某些情况下，没有基础URL。这通常意味着你有一个相对URL,但有时可能只是一个不完整或损坏了的URL。</li></ul><ol start="2"><li>解析相对引用<br>&amp;emsp;&amp;emsp;前面介绍了URL的基本组件和语法。要将相对URL转换为一个绝对URL,下一步要做的就是将相对URL和基础URL划分成组件段。实际上，这样只是在解析URL,但这种做法会将其划分成一个个组件，因此通常会称作分解(decomposing)URL。只要将基础和相对URL划分成了组件，就可以应用相应算法完成转换<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h9.jpg"><br> 以例2使用上图算法<br>(1)路径为.&#x2F;hammers.html,基础URL为 http:&#x2F;<a href="http://www.joes-hardware.comtools.html/">www.joes-hardware.comtools.html</a>.<br>(2)方案为空，沿着图表的左半边向下处理，继承基础URL方案(HTTP)。<br>(3)至少一个组件非空，一直处理到底端，继承主机和端口组件。<br>(4)将来自相对URL(路径：.hammers.html)的组件与我们继承来的组件（方案：http, 主机：<a href="http://www.joes-.hardware.com,端口：80合并起来，得到新的绝对URL">www.joes-.hardware.com,端口：80合并起来，得到新的绝对URL</a>: <a href="http://www.joes-hardware.com/hammers.html">http://www.joes-hardware.com/hammers.html</a>.</li></ol><ul><li>2.3.2 自动扩展URL</li></ul><ol><li>主机名扩展 例:输入yahoo 就会自动插入www .com构建为<a href="http://www.yahoo.com/">www.yahoo.com</a> </li><li>历史扩展 浏览器节省用户输入URL的时间,将访问过的URL历史存储起来</li></ol><h4 id="2-4-常见方案"><a href="#2-4-常见方案" class="headerlink" title="2.4 常见方案"></a>2.4 常见方案</h4><p><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h10.jpg"><br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h11.jpg"></p><p>2022&#x2F;5&#x2F;9 9:29:37 未完待续<br>&lt;此处提出反思,对读书笔记应该更加精简,简化阅读中冗余的内容,多使用概括性的话,图表等&gt;</p><h3 id="第三章-HTTP报文"><a href="#第三章-HTTP报文" class="headerlink" title="第三章 HTTP报文"></a>第三章 HTTP报文</h3><ul><li><input disabled="" type="checkbox"> 报文时如何流动的?</li><li><input disabled="" type="checkbox"> HTTP报文的三个组成部分详解</li><li><input disabled="" type="checkbox"> 请求和响应报文的区别?</li><li><input disabled="" type="checkbox"> 请求报文支持的各种方法?(get等)</li><li><input disabled="" type="checkbox"> 响应报文一起返回的状态码?(403,404)</li><li><input disabled="" type="checkbox"> 不同的HTTP首部都是什么作用</li></ul><h4 id="3-1-报文流"><a href="#3-1-报文流" class="headerlink" title="3.1 报文流"></a>3.1 报文流</h4><p>&amp;emsp;&amp;emsp;报文是HTTP应用程序间发送的数据块,流程可以理解为: 客户端发送报文 -&gt; (经过代理) -&gt; 报文流入远端服务器 -&gt; 服务器工作完成后流回用户的代理中 -&gt; (经过代理) -&gt; 客户端. <strong>HTTP报文像河水一样向下游流动</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 报文时如何流动的?</li></ul><h4 id="3-2-报文组成部分详解"><a href="#3-2-报文组成部分详解" class="headerlink" title="3.2 报文组成部分详解"></a>3.2 报文组成部分详解</h4><p>&amp;emsp;&amp;emsp;报文分为请求报文与响应报文.有三个部分组成</p><ul><li>起始行 对报文进行描述</li><li>首部块 包含属性</li><li>主体   包含数据(可选)<br>起始行与首部是由行分隔的ASC||码,每行以一个回车一个换行符(合在一起为CRLF序列)作为终止序列<br>主体是可选的数据块,二进制文件</li></ul><h5 id="3-2-1-语法"><a href="#3-2-1-语法" class="headerlink" title="3.2.1 语法"></a>3.2.1 语法</h5><ol><li>请求报文语法格式<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;<span class="hljs-keyword">method</span>&gt; &lt;<span class="hljs-title function_">request</span>-<span class="hljs-title function_">URL</span>&gt; &lt;<span class="hljs-title function_">version</span>&gt; ----起始行<br>&lt;<span class="hljs-title function_">headers</span>&gt;                        ----首部<br>&lt;<span class="hljs-title function_">entity</span>-<span class="hljs-title function_">body</span>&gt;                    ----主体<br></code></pre></td></tr></table></figure></li></ol><ul><li>方法(method)<br>客户端希望对资源的操作 (GET,PSOT,HEAD等)</li><li>请求URL(request-URL)<br>命名了所请求资源,或者完整url</li><li>版本(version)<br>报文使用的HTTP版本 <strong>HTTP&#x2F;<major><mirror> 版本格式</strong></li></ul><ol start="2"><li>响应报文语法格式<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">status</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">reason-phrase</span>&gt;</span> ----起始行<br><span class="hljs-tag">&lt;<span class="hljs-name">headers</span>&gt;</span>                          ----首部<br><span class="hljs-tag">&lt;<span class="hljs-name">entity-body</span>&gt;</span>                      ----主体<br></code></pre></td></tr></table></figure></li></ol><ul><li><p>状态码(status-code)<br>三位数字描述请求过程所发生的情况,第一位数字描述一般状态(成功,失败等)</p></li><li><p>原因短语(reason-phrase)<br>数字状态码的可读版本</p></li><li><p>首部(header)<br>**0个或多个首部 **每个首部都包含一个名字，后面跟着一个冒号(：)，然后是一个可选的空格，接着是一个值，最后是一个CLF。首部是由一个空行(CRLF)结束的，表示了首部列表的结束和实体主体部分的开始。</p></li><li><p>实体主体部分(entity-body)<br>任意数据组成的数据块</p></li><li><p><input checked="" disabled="" type="checkbox"> HTTP报文的三个组成部分详解</p></li><li><p><input checked="" disabled="" type="checkbox"> 请求和响应报文的区别?</p></li></ul><h5 id="3-2-2-起始行"><a href="#3-2-2-起始行" class="headerlink" title="3.2.2 起始行"></a>3.2.2 起始行</h5><ol><li>请求行<br><code>&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</code><strong>字段由空格分隔</strong><br>例:GET &#x2F;test&#x2F;hi-there.txt HTTP&#x2F;1.1</li></ol><ul><li>方法<br> <img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h12.jpg"></li></ul><ol start="2"><li>响应行<br><code>&lt;version&gt; &lt;status&gt; &lt;reason-phrase&gt;</code><strong>字段由空格分隔</strong><br>例:HTTP&#x2F;1.0 200 OK</li></ol><ul><li><p>状态码<br>可以通过三位数字代码对不同状态码进行分类。200到299之间的状态码表示成功。300到399之间的代码表示资源已经被移走了。400到499之间的代码表示客户端的请求出错了。500到599之间的代码表示服务器出错了。<br> <img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h13.jpg"></p></li><li><p>原因短语  作用:解释状态码</p></li></ul><p>常见状态码</p><table><thead><tr><th>状态码</th><th>原因短语</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>ok</td><td>成功,请求的所有数据都在响应主体中</td></tr><tr><td>401</td><td>Unauthorized(未授权)</td><td>需要输入用户名和密码</td></tr><tr><td>404</td><td>Not Found(未找到)</td><td>服务器无法找到请求URl对应资源</td></tr></tbody></table><ul><li>版本号</li></ul><h5 id="3-2-3-首部"><a href="#3-2-3-首部" class="headerlink" title="3.2.3 首部"></a>3.2.3 首部</h5><p><strong>注意:首部可以是0个或多个</strong></p><ol><li>首部分为通用首部,请求首部,响应首部,实体首部(描述主体长度和内容),扩展首部.</li></ol><h5 id="3-2-4-实体的主体部分"><a href="#3-2-4-实体的主体部分" class="headerlink" title="3.2.4 实体的主体部分"></a>3.2.4 实体的主体部分</h5><p>&amp;emsp;&amp;emsp;HTTP报文的负荷,即传输内容,<strong>注意:HTTP报文可以承载很多类型的数字数据:图片,视频,HTML文档,软件应用程序,电子邮件等</strong></p><p><strong>注意:HTTP 0.9版本是鼻祖,报文也由请求和响应组成,请求中只包含方法和URL,响应中支行实体</strong></p><h4 id="3-3-方法"><a href="#3-3-方法" class="headerlink" title="3.3 方法"></a>3.3 方法</h4><p>&amp;emsp;&amp;emsp;安全方法GET和HEAD DELETE和PUT方法</p><h5 id="3-3-1-GET方法"><a href="#3-3-1-GET方法" class="headerlink" title="3.3.1 GET方法"></a>3.3.1 GET方法</h5><p>&amp;emsp;&amp;emsp;GET是最常用的方法。通常用于请求服务器发送某个资源。HTTP1.1要求服务器实现此方法。下图显示了一个例子，在这个例子中，客户端用GET方法发起了一次HTTP请求。<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h14.jpg"></p><h5 id="3-3-2-HEAD方法"><a href="#3-3-2-HEAD方法" class="headerlink" title="3.3.2 HEAD方法"></a>3.3.2 HEAD方法</h5><p>&amp;emsp;&amp;emsp;HEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用HEAD,可以：</p><ul><li>在不获取资源的情况下了解资源的情况（比如，判断其类型）；</li><li>通过查看响应中的状态码，看看某个对象是否存在；</li><li>通过查看首部，测试资源是否被修改了。<br>&amp;emsp;&amp;emsp;服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。遵循HTTP1.1规范，就必须实现HEAD方法。图3-8显示了实际的HEAD方法。</li></ul><h5 id="3-3-3-PUT方法"><a href="#3-3-3-PUT方法" class="headerlink" title="3.3.3 PUT方法"></a>3.3.3 PUT方法</h5><p>&amp;emsp;&amp;emsp;与GET从服务器读取文档相反，PUT方法会向服务器写入文档。有些发布系统允许用户创建Web页面，并用PUT直接将其安装到Web服务器上去。<br>&amp;emsp;&amp;emsp;PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档，或者<strong>如果那个URL已经存在的话，就用这个主体来替代它。</strong><br>&amp;emsp;&amp;emsp;因为PUT允许用户对内容进行修改，所以很多Wb服务器都要求在执行PUT之前，用密码登录。<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h15.jpg"></p><h5 id="3-3-4-POST方法"><a href="#3-3-4-POST方法" class="headerlink" title="3.3.4 POST方法"></a>3.3.4 POST方法</h5><p>&amp;emsp;&amp;emsp;POST方法起初是用来向服务器输入数据的3。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）。下图显示了一个用POST方法发起HTTP请求一向服务器发送表单数据一的客户端。<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h16.jpg"></p><h5 id="3-3-5-TRACE方法"><a href="#3-3-5-TRACE方法" class="headerlink" title="3.3.5 TRACE方法"></a>3.3.5 TRACE方法</h5><p>&amp;emsp;&amp;emsp;客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。<br>&amp;emsp;&amp;emsp;TRACE请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求&#x2F;响应链上，原始报文是否，以及如何被毁坏或修改过。<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h17.jpg"><br>&amp;emsp;&amp;emsp;TRACE方法存在缺点,其假定中间应用程序对不同类型请求是一样的,TRACE不能区分代理的方法响应机制,通常中间应用程序会自行决定对TRACE请求的处理方式.<br><em>注意:TRACE请求不能带有实体的主体部分,TRACE响应的实体主体部分包含了响应服务器手袋的请求的精确副本</em></p><h5 id="3-3-6-OPTIONS方法"><a href="#3-3-6-OPTIONS方法" class="headerlink" title="3.3.6 OPTIONS方法"></a>3.3.6 OPTIONS方法</h5><p>&amp;emsp;&amp;emsp;OPTIONS方法请求Wb服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作)。</p><p>#####3.3.7 DELETE方法<br>&amp;emsp;&amp;emsp;DELETE方法所做的事情就是请服务器删除请求URL所指定的资源。但是，<strong>客户端应用程序无法保证删除操作一定会被执行</strong>。因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。<br><img src="/2022/04/30/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/h18.jpg"></p><ul><li><input checked="" disabled="" type="checkbox"> 请求报文支持的各种方法?(get等)</li></ul><p>2022&#x2F;5&#x2F;10 9:48:18 未完待续</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vm_ware+CentOS7 网络配置及换源教程</title>
    <link href="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/"/>
    <url>/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="vm-ware-CentOS7-网络配置及换源教程"><a href="#vm-ware-CentOS7-网络配置及换源教程" class="headerlink" title="vm_ware + CentOS7 网络配置及换源教程"></a>vm_ware + CentOS7 网络配置及换源教程</h1><h2 id="0-环境"><a href="#0-环境" class="headerlink" title="0.环境"></a>0.环境</h2><blockquote><p>Windows 10 + vmware 15 + centos 7.9</p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/Windows.jpg"></p><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/vmware.jpg"></p><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net1.jpg"></p><p>如果搭建博客还有问题的小伙伴可以参考我这一篇:<a href="https://www.cnblogs.com/silas041301/p/16172840.html">vmware+centos搭建</a></p><h2 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h2><ul><li><input disabled="" type="checkbox"> 实现虚拟机联网 可与本机相互ping通 </li><li><input disabled="" type="checkbox"> 虚拟机 ping 通外网</li><li><input disabled="" type="checkbox"> 更换CentOS yum源为阿里源 </li><li><input disabled="" type="checkbox"> 更换pip3源</li></ul><h2 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2.实现过程"></a>2.实现过程</h2><h3 id="0-本机地址-amp-虚拟机网络配置"><a href="#0-本机地址-amp-虚拟机网络配置" class="headerlink" title="(0) 本机地址 &amp; 虚拟机网络配置"></a>(0) 本机地址 &amp; 虚拟机网络配置</h3><blockquote><p>本机地址 10.26.64.244</p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net2.jpg"></p><p>打开虚拟机的编辑 -&gt; 虚拟网络编辑器 -&gt; 记录一些信息</p><blockquote><p>子网地址段 192.168.18.0 <strong>网段很重要,后面的网关和静态ip都需要前三个保持一致</strong></p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net6.jpg"></p><blockquote><p>子网掩码:255.255.255.0 (默认)<br>子网网关:192.168.18.2 (一般默认为x.x.x.2)</p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net5.jpg"></p><blockquote><p>子网的IP地址范围:192.168.18.128 ~ 192.168.18.254 <strong>等会分配静态ip时要在这个之间</strong></p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net4.jpg"></p><h3 id="1-CentOS7-网络配置"><a href="#1-CentOS7-网络配置" class="headerlink" title="(1) CentOS7 网络配置"></a>(1) CentOS7 网络配置</h3><h4 id="a-修改系统网卡"><a href="#a-修改系统网卡" class="headerlink" title="a.修改系统网卡"></a>a.修改系统网卡</h4><ol><li><code>ifconfig</code> 查看CentOS 的网卡<br><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net8.jpg"><br>此处显示 网卡为ens33 状态00:0c:29:08:58:a9 即无网络连接</li><li><code>cd /etc/sysconfig/network-scripts</code>进入网络配置文件夹</li><li><code>ls</code> 显示当前文件夹<br><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net9.jpg"></li><li><code>sudo vi ifcfg-ens33</code>此处修改默认网卡的配置文件<strong>对应第一步看到的默认网卡文件</strong><br><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net10.jpg"></li><li>按键<code>a</code>后进入编辑模式,将文件修改(参考下面代码块)</li><li><code>:wq!</code>保存并退出</li><li><code>systemctl restart network.service</code>重启网络服务</li><li>测试一下<code>ping www.baidu.com</code>以及<code>ping 10.26.64.244</code>后面是之前获得的本机ip地址,结果如下,网络配置成功<br><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net11.jpg"></li></ol><ul><li><input checked="" disabled="" type="checkbox"> 实现虚拟机联网 可与本机相互ping通 </li><li><input checked="" disabled="" type="checkbox"> 虚拟机 ping 通外网</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">TYPE</span>=Ethernet<br><span class="hljs-attr">PROXY_METHOD</span>=none<br><span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">BOOTPROTO</span>=static  <span class="hljs-comment">#设置ip为静态#</span><br><span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=stable-privacy<br><span class="hljs-attr">NAME</span>=ens33     <span class="hljs-comment">#设定网卡的名称，要跟文件名称对应 #</span><br><span class="hljs-attr">UUID</span>=f5e37a10-<span class="hljs-number">3</span>da9-<span class="hljs-number">47</span>af-<span class="hljs-number">8</span>dbb-<span class="hljs-number">370</span>b7bf24509 <br><span class="hljs-attr">DEVICE</span>=ens33   <span class="hljs-comment">#设定网卡的名称，要跟文件名称对应 #</span><br><span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span>     <span class="hljs-comment">#是否在开机的的时候启动网卡,改为yes# </span><br><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">18.140</span>     <span class="hljs-comment">#IP 地址需要在上面的范围内 必须设置#   </span><br><span class="hljs-attr">GATEWAY</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">18.2</span>      <span class="hljs-comment">#网关地址 在之前的一步中已经获得 必须设置#</span><br><span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>     <span class="hljs-comment">#子网掩码  必须设置# </span><br><span class="hljs-attr">DNS1</span>=<span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span>  <span class="hljs-comment">#域名服务器 8.8.8.8 114.114.114.114 都可 同样支持多个域名服务器#  </span><br><br><span class="hljs-attr">NETWORK</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">18.129</span>　　   <span class="hljs-comment">#该网段的第一个 IP# 可以不设置</span><br><span class="hljs-attr">BROADCAST</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">18.255</span>　　<span class="hljs-comment">#最后一个同网段的广播地址#  可以不设置</span><br></code></pre></td></tr></table></figure><h3 id="2-对CentOS的下载源-换源"><a href="#2-对CentOS的下载源-换源" class="headerlink" title="(2)对CentOS的下载源 换源"></a>(2)对CentOS的下载源 换源</h3><p>由于系统本身的源服务器在国外,域名解析后的下载和访问速度感人,而国内阿里,网易和清华等镜像源访问速度更快,可以将yum源换为国内源.</p><ol><li>备份yum源配置文件<code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></li><li>下载新的CentOS-Base.repo 到&#x2F;etc&#x2F;yum.repos.d&#x2F; 这里以阿里源为例  <code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></li><li>yum清理缓存 生成新的缓冲<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">yum clean <span class="hljs-keyword">all</span><br>yum makecache<br></code></pre></td></tr></table></figure></li></ol><ul><li><input checked="" disabled="" type="checkbox"> 更换CentOS yum源为阿里源</li></ul><h3 id="3-对pip3换源"><a href="#3-对pip3换源" class="headerlink" title="(3)对pip3换源"></a>(3)对pip3换源</h3><p>由于网络有时不稳定的原因，使用pip&#x2F;pip3下载会非常慢。如果使用国内镜像服务就完美的解决了下载速度慢的问题</p><p>临时使用：<br>可以在使用pip的时候在后面加上-i参数，指定pip源<br>eg: pip install xxxx -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><ol><li>进入根目录 <code>cd ~</code></li><li>创建文件夹 <code>mkdir .pip</code></li><li>进入文件夹创建文件 <code>cd .pip</code> <code>vim pip.conf</code></li><li>文件内容参考下代码块</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br><span class="hljs-keyword">index</span>-url=https://pypi.tuna.tsinghua.edu.cn/simple<br><span class="hljs-keyword">trusted</span>-host = pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 更换pip3源</li></ul><h2 id="3-参考博客"><a href="#3-参考博客" class="headerlink" title="3.参考博客"></a>3.参考博客</h2><ol><li><a href="https://blog.csdn.net/weixin_44110998/article/details/104042358">https://blog.csdn.net/weixin_44110998/article/details/104042358</a></li><li><a href="https://blog.csdn.net/akipa11/article/details/81414875">https://blog.csdn.net/akipa11/article/details/81414875</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux系统</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vm_ware虚拟机安装CentOS7教程</title>
    <link href="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/"/>
    <url>/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="VM-Ware虚拟机-CentOS-7-系统安装教程"><a href="#VM-Ware虚拟机-CentOS-7-系统安装教程" class="headerlink" title="VM_Ware虚拟机+CentOS 7 系统安装教程"></a>VM_Ware虚拟机+CentOS 7 系统安装教程</h1><h2 id="0-安装环境"><a href="#0-安装环境" class="headerlink" title="0.安装环境"></a>0.安装环境</h2><blockquote><p>Windows 10 + vmware 15 + centos 7.9</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/Windows.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/vmware.jpg"></p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><h3 id="1-下载CentOS镜像"><a href="#1-下载CentOS镜像" class="headerlink" title="(1)下载CentOS镜像"></a>(1)下载CentOS镜像</h3><p>可以访问<a href="https://mirrors.aliyun.com/centos">阿里云的CentOS镜像网站</a>进行下载</p><h4 id="step1-访问网站"><a href="#step1-访问网站" class="headerlink" title="step1:访问网站"></a>step1:访问网站</h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/1.jpg"></p><h4 id="step2-找到对应版本"><a href="#step2-找到对应版本" class="headerlink" title="step2:找到对应版本"></a>step2:找到对应版本</h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/2.jpg"></p><h4 id="step3-进入文件夹找到isos镜像文件夹"><a href="#step3-进入文件夹找到isos镜像文件夹" class="headerlink" title="step3:进入文件夹找到isos镜像文件夹"></a>step3:进入文件夹找到isos镜像文件夹</h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/3.jpg"></p><h4 id="step4-找到X86-64文件夹"><a href="#step4-找到X86-64文件夹" class="headerlink" title="step4:找到X86_64文件夹"></a>step4:找到X86_64文件夹</h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/4.jpg"></p><h4 id="step5-根据个人需求下载对应的镜像-可以阅读此文件下的0-README-txt文件查看不同版本的区别-readme文件翻译部分放在下面-注意-记住下载的位置-之后安装会使用到"><a href="#step5-根据个人需求下载对应的镜像-可以阅读此文件下的0-README-txt文件查看不同版本的区别-readme文件翻译部分放在下面-注意-记住下载的位置-之后安装会使用到" class="headerlink" title="step5:根据个人需求下载对应的镜像(可以阅读此文件下的0_README.txt文件查看不同版本的区别,readme文件翻译部分放在下面)注意:记住下载的位置,之后安装会使用到"></a>step5:根据个人需求下载对应的镜像(可以阅读此文件下的0_README.txt文件查看不同版本的区别,readme文件翻译部分放在下面)<strong>注意:记住下载的位置,之后安装会使用到</strong></h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/5.jpg"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs subunit">CentOS<span class="hljs-string">-7</span>-x86_64-DVD<span class="hljs-string">-1804</span>.iso<br>这个DVD image包含了可以使用下载器下载的所有包。想使用CentOS的小伙伴都可以下载这个image，面向大部分用户。<br> <br>CentOS<span class="hljs-string">-7</span>-x86_64-NetInstall<span class="hljs-string">-1804</span>.iso<br>这是网络安装和救援image。安装人员会询问应该从哪里获取要安装的软件包。如果您有CentOS软件包的本地镜像，则非常有用。<br> <br>CentOS<span class="hljs-string">-7</span>-x86_64-Everything<span class="hljs-string">-1804</span>.iso<br>这个image包含Centos Linux 7完整的软件包，可用于安装或填充本地镜像。此图像需要16GB USB 闪存，因为它太大了（9G）。<br> <br>CentOS<span class="hljs-string">-7</span>-x86_64-LiveGNOME<span class="hljs-string">-1804</span>.iso<br>CentOS<span class="hljs-string">-7</span>-x86_64-LiveKDE<span class="hljs-string">-1804</span>.iso<br>这些images是CentOS Linux 7的Live image。根据名称，它们使用相应的显示管理器。它们专为测试目的和探索CentOS Linux 7环境而设计。除非您选择从Live环境中安装CentOS Linux 7，否则它们不会修改硬盘的内容。请注意，在这种情况下，您无法更改已安装的软件包集。这需要使用yum在已安装的系统中完成。<br> <br>CentOS<span class="hljs-string">-7</span>-x86_64-Minimal<span class="hljs-string">-1804</span>.iso<br>这个image的目的是安装一个非常基本的CentOS Linux 7系统，只需要最少的软件包即可拥有一个功能系统。请将此图像刻录到CD上并启动计算机。系统上将安装一组预先选择的软件包。其他所有东西都需要使用yum安装。此映像安装的软件包集与从完整DVD映像中选择名为“Minimal”的组时安装的软件包相同。<br><br></code></pre></td></tr></table></figure><h2 id="2-系统安装"><a href="#2-系统安装" class="headerlink" title="2.系统安装"></a>2.系统安装</h2><h3 id="1-虚拟机配置"><a href="#1-虚拟机配置" class="headerlink" title="(1)虚拟机配置"></a>(1)虚拟机配置</h3><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos1.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos2.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos3.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos4.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos5.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos6.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos7.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos8.jpg"></p><blockquote><p>此处网络配置 我选择的是使用本机的ip访问外部网络,如果不需要网络或者只在主机和虚拟机通信可以选择对应的选项.而需要独立的ip可以选择桥接模式</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos9.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos10.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos11.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos12.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos13.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos14.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos15.jpg"></p><h3 id="2-虚拟机挂载镜像"><a href="#2-虚拟机挂载镜像" class="headerlink" title="(2)虚拟机挂载镜像"></a>(2)虚拟机挂载镜像</h3><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos16.jpg"></p><blockquote><p>此处使用到之前下载的镜像文件</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos17.jpg"></p><blockquote><p>开启虚拟机则进入安装过程</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos18.jpg"></p><h3 id="3-系统安装及初始化"><a href="#3-系统安装及初始化" class="headerlink" title="(3)系统安装及初始化"></a>(3)系统安装及初始化</h3><blockquote><p>选择第一项 安装即可</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos19.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos20.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos21.jpg"></p><blockquote><p>注意:<strong>此处软件选择,需要图形界面选择gui图形界面,我选择最小安装则无图型界面,只有命令行,如果是初学者还是选择有gui图形界面的安装</strong></p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos22.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos23.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos24.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos25.jpg"></p><blockquote><p>注意:<strong>root密码一定要记住,最好创建一个用户,不要在root下使用(很危险)</strong></p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos26.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos27.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos28.jpg"></p><blockquote><p>重启后系统已经在运行,这里提示登录,由于刚刚已经创建了用户,可以输入用户名,回车后输入密码登录</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos29.jpg"></p><blockquote><p>到这里已经安装完成,使用<code>uname -a</code>指令看一下系统信息,这样就安装成功了</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos30.jpg"></p><h3 id="4-创建系统快照-出问题可以回溯"><a href="#4-创建系统快照-出问题可以回溯" class="headerlink" title="(4)创建系统快照,出问题可以回溯"></a>(4)创建系统快照,出问题可以回溯</h3><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos31.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos32.jpg"></p><h2 id="3-借鉴网址"><a href="#3-借鉴网址" class="headerlink" title="3.借鉴网址"></a>3.借鉴网址</h2><ol><li>感兴趣的可以参考<a href="https://www.haah.net/vm-station">虚拟机建站博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/145102034">知乎帖子</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux系统</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A-Tune的centos安装</title>
    <link href="/2022/04/20/A-Tune%E7%9A%84centos%E5%AE%89%E8%A3%85/"/>
    <url>/2022/04/20/A-Tune%E7%9A%84centos%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Tune在CentOS的移植"><a href="#A-Tune在CentOS的移植" class="headerlink" title="A-Tune在CentOS的移植"></a>A-Tune在CentOS的移植</h1><h2 id="第一-安装环境"><a href="#第一-安装环境" class="headerlink" title="第一.安装环境"></a>第一.安装环境</h2><h3 id="vm-ware虚拟机-centos-7-9"><a href="#vm-ware虚拟机-centos-7-9" class="headerlink" title="vm ware虚拟机 + centos 7.9"></a>vm ware虚拟机 + centos 7.9</h3><p><img src="/2022/04/20/A-Tune%E7%9A%84centos%E5%AE%89%E8%A3%85/a1.jpg"></p><h2 id="第二-安装步骤"><a href="#第二-安装步骤" class="headerlink" title="第二.安装步骤"></a>第二.安装步骤</h2><h3 id="0-环境准备"><a href="#0-环境准备" class="headerlink" title="0.环境准备"></a>0.环境准备</h3><p>系统应该配置网络,保证可以ping通外网,具体实现借鉴可以我的另一篇博客<br><a href="https://www.cnblogs.com/silas041301/p/16175861.html">https://www.cnblogs.com/silas041301/p/16175861.html</a><br>由于CentOS使用的yum源 和 pip源会出现连接问题 ,可以将其换为国内的源</p><h3 id="1-安装安装依赖系统软件包"><a href="#1-安装安装依赖系统软件包" class="headerlink" title="1.安装安装依赖系统软件包"></a>1.安装安装依赖系统软件包</h3><p><code>yum install -y golang-bin python3 perf sysstat hwloc-gui</code><br>:star:此处如果出现报错大概率由于国外源的问题,可以换源</p><h3 id="2-安装python依赖包"><a href="#2-安装python依赖包" class="headerlink" title="2.安装python依赖包"></a>2.安装python依赖包</h3><h4 id="2-1-安装A-Tune服务的依赖包"><a href="#2-1-安装A-Tune服务的依赖包" class="headerlink" title="2.1 安装A-Tune服务的依赖包"></a>2.1 安装A-Tune服务的依赖包</h4><p>使用指令<br><code>pip3 install dict2xml Flask-RESTful pandas scikit-optimize xgboost scikit-learn pyyaml</code><br>此处安装时出现了一些问题 见后文3.1</p><h4 id="2-2-安装数据库依赖包"><a href="#2-2-安装数据库依赖包" class="headerlink" title="2.2 安装数据库依赖包"></a>2.2 安装数据库依赖包</h4><p>使用<br><code>yum install -y python3-sqlalchemy python3-cryptography</code><br>或者<br><code>pip3 install sqlalchemy cryptography</code></p><p>此处出现的python版本问题见 3.2</p><p>同时对应数据库安装依赖这里以<strong>PostgreSQL</strong>数据库为例<br><code>yum install -y python3-psycopg2</code>或者<code>pip3 install psycopg2</code></p><h4 id="2-3-下载源码"><a href="#2-3-下载源码" class="headerlink" title="2.3 下载源码"></a>2.3 下载源码</h4><p><code>git clone https://gitee.com/openeuler/A-Tune.git</code></p><h4 id="2-4-编译"><a href="#2-4-编译" class="headerlink" title="2.4 编译"></a>2.4 编译</h4><pre><code class="hljs">cd A-Tunemake</code></pre><h4 id="2-5-安装"><a href="#2-5-安装" class="headerlink" title="2.5 安装"></a>2.5 安装</h4><pre><code class="hljs">make collector-installmake install</code></pre><h2 id="第三-遇到的问题与解决"><a href="#第三-遇到的问题与解决" class="headerlink" title="第三.遇到的问题与解决"></a>第三.遇到的问题与解决</h2><h3 id="3-1-在安装xgboost时出现报错"><a href="#3-1-在安装xgboost时出现报错" class="headerlink" title="3.1 在安装xgboost时出现报错"></a>3.1 在安装xgboost时出现报错</h3><p><img src="/2022/04/20/A-Tune%E7%9A%84centos%E5%AE%89%E8%A3%85/a2.jpg"></p><p>【报错】:Command “&#x2F;usr&#x2F;bin&#x2F;python3 -u -c “import setuptools, tokenize;<strong>file</strong>&#x3D;’&#x2F;tmp&#x2F;pip-build-ktq1dypw&#x2F;xgboost&#x2F;setup.py’;f&#x3D;getattr(tokenize, ‘open’, open)(<strong>file</strong>);code&#x3D;f.read().replace(‘\r\n’, ‘\n’);f.close();exec(compile(code, <strong>file</strong>, ‘exec’))” install –record &#x2F;tmp&#x2F;pip-1wala8fx-record&#x2F;install-record.txt –single-version-externally-managed –compile” failed with error code 1 in &#x2F;tmp&#x2F;pip-build-ktq1dypw&#x2F;xgboost&#x2F;<br>【原因】:安装工具包时需要抓取网页因而要处理 https，而处理 https 又依赖加解密算法（即 cryptography 包），而 cryptography 又依赖傅立叶变换的算法以及相应的编译环境。Ubuntu 16.04 默认没有安装 libffi-dev 和 libssl-dev，gcc 也不一定安装，而 目标安装包又没有将相关软件包记到依赖列表里，<br>【解决方法】:sudo pip3 install python3-setuptools</p><p><strong>在使用上述方法后问题未解决</strong></p><p><img src="/2022/04/20/A-Tune%E7%9A%84centos%E5%AE%89%E8%A3%85/a3.jpg"><br>【报错】显示setuptools已经安装<br>【原因】所需要的依赖包所在的setuptools dust需要的是pip 2.x版本的<br>【解决方法】</p><ol><li>首先需要安装pip old version 并下载pip2 的setuptools<code>pip3 install -U pip setuptools</code></li><li>使用pip安装对应的依赖包 <code>pip install cryptography --force-reinstall</code> and <code>pip install paramiko --force-reinstall</code></li><li>依赖包安装成功,可以使用pip 安装xgboost了,但会出现一个warning</li></ol><p><img src="/2022/04/20/A-Tune%E7%9A%84centos%E5%AE%89%E8%A3%85/a4.jpg"><br>【警告】WARNING: pip is being invoked by an old script wrapper. This will fail in a future version of pip.<br>Please see <a href="https://github.com/pypa/pip/issues/5599">https://github.com/pypa/pip/issues/5599</a> for advice on fixing the underlying issue.<br>To avoid this problem you can invoke Python with ‘-m pip’ instead of running pip directly.<br>Looking in indexes: <a href="http://mirrors.aliyun.com/pypi/simple">http://mirrors.aliyun.com/pypi/simple</a><br>【原因】pip正在被一个旧的脚本包装器调用。 这将在pip的未来版本中失败<br>该问题出现于我在系统下使用如下命令安装了一个新版本的pip后，使用原先的pip3进行一些操作出现的提问。<br>【解决方法】<code>python3 -m pip install --upgrade pip</code>使用如下命令卸载这个新的pip即可<code>pip3 uninstall pip</code></p><h3 id="3-2-python版本依赖以及连接问题"><a href="#3-2-python版本依赖以及连接问题" class="headerlink" title="3.2 python版本依赖以及连接问题"></a>3.2 python版本依赖以及连接问题</h3><p>【原因】:首先明确一般的linux系统自带Python2.x，原因是一些内部程序需要Python2.x的支持，而如今Python3早已成为主流，显然自带的Python2已经无法满足我们使用的需求。所以就会想着去安装Python3   </p><p><strong>踩坑</strong><br>为了服务器上centos系统的纯净性，以及避免潜在的python版本共存的冲突，第一件事情就是去把python2给卸载了，但实际上千万不要这么做，因为譬如centos的yum也会跟着被删除。<br>【解决方法】</p><ul><li><input disabled="" type="checkbox"> 安装python3.6.5<br>Step 1  先去python官网下载python3安装包<br>执行命令:<br><code>wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz </code><br>Step 2 安装zlib-devel包(后面安装pip需要用到,这里先下载，后面就不用重复编译)<br><code>yum install zlib-devel</code><br>Step 3 解压命令:<br><code>tar -xvf Python-3.6.5.tgz </code><br>Step 4 将解压文件移动到 usr&#x2F;local目录下<br><code>mv Python-3.6.5 /usr/local</code><br>Step 5 在local目录下创建python3目录<br><code>mkdir /usr/local/python3</code><br>Step 6 转到解压文件夹下<br><code>cd /usr/local/Python-3.6.5</code>配置安装目录<br><code>./configure --prefix=/usr/local/python</code><br>Step 7 编译源码及安装<br><code>make &amp;&amp; make install</code><br>Step 8 配置软连接</li></ul><p>(1). 若不需要将python3设置为默认:<br><code>ln -s /usr/local/python3/bin/python3 /usr/bin/python3</code><br>(2).若需要将python3设置为默认:<br>即还需要修改yum配置，使用vi打开 &#x2F;usr&#x2F;bin&#x2F;yum 即：<br><code>vim /usr/bin/yum</code><br>将第一行的#! &#x2F;usr&#x2F;bin&#x2F;python修改为#! &#x2F;usr&#x2F;bin&#x2F;python2</p><p>(3).同理vi &#x2F;usr&#x2F;libexec&#x2F;urlgrabber-ext-down将文件里面的<br><code>#! /usr/bin/python 也要修改为#! /usr/bin/python2</code><br>(4).删除原有的软连接慎用:<br><code>rm -rf /usr/bin/python</code><br>(5).建立新的软连接:<br><code>ln -s /usr/local/python3/bin/python3 /usr/bin/python</code><br>测试:&#96;python<br>结果<br>Python3是装上了，但实际上yum也不能少，还是得去安装Python2<br>所以最明智的做法就是不卸载原有的Python2 直接采取共存的方式管理python</p><p>如果真的卸载了也没关系<br>使用wget分别下载python以及yum的rpm包注意：一定要和系统的版本号对应<br>（1）下载python的rpm包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /usr/local/src/python进入目录<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/python-<span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">5</span>-<span class="hljs-number">34</span>.el7.x86_64.rpm<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/python-iniparse-<span class="hljs-number">0</span>.<span class="hljs-number">4</span>-<span class="hljs-number">9</span>.el7.noarch.rpm<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/python-pycurl-<span class="hljs-number">7</span>.<span class="hljs-number">19</span>.<span class="hljs-number">0</span>-<span class="hljs-number">17</span>.el7.x86_64.rpm<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/python-devel-<span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">5</span>-<span class="hljs-number">34</span>.el7.x86_64.rpm<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/python-libs-<span class="hljs-number">2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">5</span>-<span class="hljs-number">34</span>.el7.x86_64.rpm<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/python-urlgrabber-<span class="hljs-number">3</span>.<span class="hljs-number">10</span>-<span class="hljs-number">7</span>.el7.noarch.rpm<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/rpm-python-<span class="hljs-number">4</span>.<span class="hljs-number">11</span>.<span class="hljs-number">3</span>-<span class="hljs-number">17</span>.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><p>（2）下载yum的rpm包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> /usr/local/src/yum<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/yum-<span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">3</span>-<span class="hljs-number">132</span>.el7.centos.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.noarch.rpm<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/yum-metadata-parser-<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">4</span>-<span class="hljs-number">10</span>.el7.x86_64.rpm<br><span class="hljs-attribute">wget</span> http://vault.centos.org/<span class="hljs-number">7</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1511</span>/os/x86_64/Packages/yum-plugin-fastestmirror-<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">31</span>-<span class="hljs-number">34</span>.el7.noarch.rpm<br></code></pre></td></tr></table></figure><p>5.安装python以及yum的rpm包<br>（1）安装python:</p><pre><code class="hljs">cd /usr/local/src/pythonrpm -ivh python-* rpm-python-*</code></pre><p>出现安装包的依赖问题，此时如下解决即可：<br><code>rpm -ivh python-* rpm-python-* --nodeps --force</code><br>–nodeps –force为不考虑依赖包，强制安装。<br>安装完后即可运行python<br>（2）安装yum:</p><pre><code class="hljs">cd /usr/local/src/yum rpm -ivh yum-*</code></pre><p>如果遇到依赖问题，请注意rpm安装顺序，考虑不直接用*安装全部而是一个一个安装，因为可能会互相依赖。</p><h2 id="第四-借鉴网址"><a href="#第四-借鉴网址" class="headerlink" title="第四.借鉴网址"></a>第四.借鉴网址</h2><p>[1]<a href="https://gitee.com/openeuler/A-Tune?utm_source=alading&amp;utm_campaign=repo">https://gitee.com/openeuler/A-Tune?utm_source=alading&amp;utm_campaign=repo</a></p>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
      <category>A-Tune</category>
      
    </categories>
    
    
    <tags>
      
      <tag>A-Tune</tag>
      
      <tag>Linux系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建和使用</title>
    <link href="/2022/03/22/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/22/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo与Github-pages-实现静态博客"><a href="#Hexo与Github-pages-实现静态博客" class="headerlink" title="Hexo与Github pages 实现静态博客"></a>Hexo与Github pages 实现静态博客</h1><h2 id="第一-博客搭建"><a href="#第一-博客搭建" class="headerlink" title="第一.博客搭建"></a>第一.博客搭建</h2><h3 id="1-hexo"><a href="#1-hexo" class="headerlink" title="1.hexo"></a>1.hexo</h3><h4 id="1-hexo是什么"><a href="#1-hexo是什么" class="headerlink" title="(1)hexo是什么"></a>(1)hexo是什么</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="2-hexo安装"><a href="#2-hexo安装" class="headerlink" title="(2)hexo安装"></a>(2)hexo安装</h4><h5 id="a-安装前提"><a href="#a-安装前提" class="headerlink" title="a.安装前提"></a>a.安装前提</h5><p>安装Hexo前，需要先安装下列应用程序：</p><ul><li>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li>Git</li></ul><p><strong>git 和 node 的安装方法 在后面hexo + github pages给出 着急的小伙伴可以直接从那里开始看</strong></p><h5 id="b-安装-Hexo"><a href="#b-安装-Hexo" class="headerlink" title="b.安装 Hexo"></a>b.安装 Hexo</h5><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre><code class="hljs">$ npm install -g hexo-cli或者$ npm install hexo</code></pre><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><p>npx hexo <command></p></li><li><p>将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo <command>：</p><p> echo ‘PATH&#x3D;”$PATH:.&#x2F;node_modules&#x2F;.bin”‘ &gt;&gt; ~&#x2F;.profile</p></li></ol><h3 id="2-Github-page"><a href="#2-Github-page" class="headerlink" title="2.Github page"></a>2.Github page</h3><h4 id="1-github-page创建"><a href="#1-github-page创建" class="headerlink" title="(1) github page创建"></a>(1) github page创建</h4><p>基本页面的生成  </p><ol><li>首先你需要注册一个 GitHub 账号，并在个人主界面里选择创建一个新的 Repository 。  </li><li>进入页面后，在 Repository name 的位置填写域名，格式是 username.GitHub.io。</li><li>创建成功之后，点击右上角的 Settings找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题</li><li>选择完毕之后 GitHub Pages 就会自动帮你生成好网站，在他跳转的界面点击 Commit changes 按钮，网站就可以访问了。</li><li>在浏览器里输入你的项目名称，比如 brick713.GitHub.io，就可以看到，你刚刚选择的主题的个人网站的页面了。</li></ol><h3 id="3-hexo-Github-page"><a href="#3-hexo-Github-page" class="headerlink" title="3.hexo +　Github page"></a>3.hexo +　Github page</h3><h4 id="1-git"><a href="#1-git" class="headerlink" title="(1).git"></a>(1).git</h4><h5 id="a-git安装"><a href="#a-git安装" class="headerlink" title="a. git安装"></a>a. git安装</h5><ul><li>windows下载安装 <a href="https://git-scm.com/download/win">git</a></li><li>linux下载安装指令<br><code>sudo apt-get install git-core</code> 或者<code>sudo yum install git-core</code></li></ul><h5 id="b-git和github绑定"><a href="#b-git和github绑定" class="headerlink" title="b. git和github绑定"></a>b. git和github绑定</h5><ol><li><p>安装成功后，将 git 与 GitHub 账号绑定，右键打开 Git Bash</p></li><li><p>配置用户名和邮箱<br><code>git config --global user.name &quot;github 用户名&quot;</code><br><code>git config --global user.email &quot;github 注册邮箱&quot;</code></p></li><li><p>生成 ssh 密钥<br><code>ssh-keygen -t rsa -C &quot;github 注册邮箱&quot;</code></p></li><li><p>一般执行上述命令之后，会生成 id_rsa 和 id_rsa.pub 两个文件，前者是我们私有的，而后者则是对外开放的。接着找到生成的 .ssh 的文件夹中id_rsa.pub 密钥，将内容复制,然后打开 GitHub-Settings-Keys 页面，创建一个新的 SSH key，填写 Title 和 Key，Title 可以随意，而 Key 的内容则是我们刚才复制的 id_rsa.pub 中的内容，最后点击 Add SSH key 即可</p></li></ol><h4 id="2-node-js"><a href="#2-node-js" class="headerlink" title="(2).node.js"></a>(2).node.js</h4><h5 id="a-node-js安装"><a href="#a-node-js安装" class="headerlink" title="a. node.js安装"></a>a. node.js安装</h5><ul><li>下载<a href="https://nodejs.org/en/">node.js下载</a></li><li>一直下一步即可</li><li>验证 在命令行输入 node -v可以查看版本</li></ul><h5 id="b-node-js初始化"><a href="#b-node-js初始化" class="headerlink" title="b. node.js初始化"></a>b. node.js初始化</h5><ul><li>在git bash中安装<br><code> npm i hexo-cli -g</code></li><li>选择一个文件夹来放置博客文件,并用如下命令进行初始化并安装必备组件<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在对应文件夹下git bash here<br> hexo init .<br> npm install<br></code></pre></td></tr></table></figure><h5 id="c-初始化后的文件"><a href="#c-初始化后的文件" class="headerlink" title="c.初始化后的文件"></a>c.初始化后的文件</h5></li><li>_config.yml # 网站配置信息</li><li>package.json # 应用程序信息</li><li>scaffolds # 模板文件夹</li><li>source # 存放用户资源 _drafts 草稿箱  _posts 文章</li><li>themes # 主题文件夹</li></ul><h4 id="3-将自己的github网址-替换-config-yml最后的"><a href="#3-将自己的github网址-替换-config-yml最后的" class="headerlink" title="(3) 将自己的github网址 替换 _config.yml最后的"></a>(3) 将自己的github网址 替换 _config.yml最后的</h4><pre><code class="hljs">deploy:  type: git  repo: //此处替换为自己的github的对应仓库网址    例:https://github.com/xxxxx/xxxxx.github.io.git  branch: master</code></pre><h2 id="第二-博客使用"><a href="#第二-博客使用" class="headerlink" title="第二.博客使用"></a>第二.博客使用</h2><h3 id="1-新建博客"><a href="#1-新建博客" class="headerlink" title="1.新建博客"></a>1.新建博客</h3><p>在搭建博客的文件夹中git bash here 进入到 Blog&#x2F;source&#x2F;_post文件夹中(_post为默认选项 即发表文章) </p><blockquote><p>可以在source文件夹中创建文件夹 new时加参数 例如草稿箱_draft)</p></blockquote><pre><code class="hljs">hexo new [layout] &lt;title&gt;例如 hexo new &quot;我的博客&quot; hexo new post &quot;我的文章&quot; //就会在/source/_post文件创建名为 我的文章.md的文件hexo new draft &quot;我的草稿&quot; //就会在/source/_draft文件创建名为 我的草稿.md的文件</code></pre><p>其中[layout]为布局  </p><ul><li>创建md文件时可以指定布局</li><li>包括三种布局 page draft post分别为页面,草稿,文章  默认为post  </li><li>在新建文件时，Hexo 会根据 scaffolds 文件夹内相对应的文件（可以理解为模板）来建立md文件</li><li>当创建不同的md文件会在不同的存储路径</li></ul><blockquote><p>注意但不想一个文件显示在页面上时,可以移动到_draft文件夹</p><ul><li>在启动服务器时加上 –draft来查看草稿</li><li>还可以在站点配置文件中把render_drafts设为true 可以通过publish将草稿发布文章或者页面</li></ul></blockquote><pre><code class="hljs">hexo server --drafthexo publish [layout] &lt;title&gt;</code></pre><h3 id="2-博客编写"><a href="#2-博客编写" class="headerlink" title="2.博客编写"></a>2.博客编写</h3><h4 id="1-Front-matter"><a href="#1-Front-matter" class="headerlink" title="(1)Front-matter"></a>(1)Front-matter</h4><p>创建一个文件后可以看到这些,成为Front-matter</p><pre><code class="hljs">---title: hexo博客搭建和使用tags:---</code></pre><p>此处包括一些预定义参数如下</p><pre><code class="hljs">layout  布局  默认为true，如果你不想你的文章被处理，可以设置为falsetitle  标题  标题会显示在最上方居中位置 date  建立日期如果不指定则为默认值-文件创建日期，可以自定义。update  更新日期  如果不指定则为默认值-文件修改后重新生成静态文件的日期。comments  是否开启文章的评论功能 默认值为truetags  标签（不适用于页面page布局）categoreies  分类（不适用于页面page布局）permalink  覆盖文章网址keywords  仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</code></pre><p>举个例子</p><pre><code class="hljs">---title: hexo博客搭建和使用date: 2022-03-22 11:51tags:- 博客搭建categories:- 个人博客- 博客搭建使用---</code></pre><h4 id="2-博客正文编写"><a href="#2-博客正文编写" class="headerlink" title="(2)博客正文编写"></a>(2)博客正文编写</h4><p>使用markdow文法编写博客,保存<br>markdown语法可以参考这个<a href="https://markdown.com.cn/">markdown官方语法</a></p><h3 id="3-博客预览和发布"><a href="#3-博客预览和发布" class="headerlink" title="3.博客预览和发布"></a>3.博客预览和发布</h3><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="(1)基本操作"></a>(1)基本操作</h4><p>一般发布文章或者修改博客后需要这些操作：</p><ul><li>清除缓存</li><li>生成静态文件</li><li>启动服务器</li><li>测试没问题</li><li>部署</li></ul><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="(2)常用命令"></a>(2)常用命令</h4><ul><li>清除缓存：hexo clean</li><li>生成静态文件：hexo generate可简写为 hexo g</li><li>启动服务器：hexo server或者 hexo s  此处默认的端口号为4000 可以使用-p（–port）重设端口,此处使用浏览器浏览localhost:4000可以预览自己的博客</li><li>部署：hexo deploy可简写为hexo d，用于将网站部署到服务器上。将博客托管到GitHub Pages或Gitee Pages 注意:此处可以使用-g（–generate），hexo d -g部署前预先生成静态文件，等同于 hexo g -d</li></ul><p>举个例子</p><pre><code class="hljs"> hexo clean   hexo g  hexo s //此处注意预览完在git bash窗口Ctrl+c关闭,直接关闭浏览器可能会使端口无法释放 hexo d</code></pre>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>博客相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIDI播放器开发(一)</title>
    <link href="/2022/03/13/MIDI%E6%92%AD%E6%94%BE%E5%99%A8%E5%BC%80%E5%8F%91-%E4%B8%80/"/>
    <url>/2022/03/13/MIDI%E6%92%AD%E6%94%BE%E5%99%A8%E5%BC%80%E5%8F%91-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="MIDI-player-开发流程及问题归纳-一"><a href="#MIDI-player-开发流程及问题归纳-一" class="headerlink" title="MIDI_player 开发流程及问题归纳(一)"></a>MIDI_player 开发流程及问题归纳(一)</h1><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><ul><li>Swing GUI</li><li>网络连接</li><li>将数据传输到I&#x2F;O设备</li><li>JavaSound的API</li></ul><h2 id="第一部分-JavaSound-API"><a href="#第一部分-JavaSound-API" class="headerlink" title="第一部分 JavaSound API"></a>第一部分 JavaSound API</h2><h3 id="1-异常理解"><a href="#1-异常理解" class="headerlink" title="1. 异常理解"></a>1. 异常理解</h3><p>在MusicTest1.java文件编译时出现报错<br>【报错】:  </p><blockquote><p>$ javac MusicTest1.java<br>MusicTest1.java:5: 错误: 未报告的异常错误<br>MidiUnavailableException; 必须对其进行捕获或声明以便抛<br>Sequencer sequencer &#x3D; MidiSystem.getSequencer();<br>1 个错误  </p></blockquote><p>【解决方法】:此处是Java编译器要我们知道调用的方法有风险,使用API帮助文档查看此函数  </p><blockquote><p>public static Sequencer getSequencer()<br>throws MidiUnavailableException获取默认设备Sequencer ，连接到默认设备。<br>返回的Sequencer实例连接到默认的Synthesizer ，如getSynthesizer()所示 。<br>如果没有Synthesizer可用，或默认Synthesizer无法打开，则sequencer连接到默认值Receiver ，由getReceiver()返回。<br>连接是通过检索取得Transmitter从实例Sequencer并设置其Receiver 。 关闭并重新打开音序器将恢复与默认设备的连接。<br>此方法相当于调用getSequencer(true) 。 </p><p>如果系统属性javax.sound.midi.Sequencer已被定义或在文件“sound.properties”中定义，则用于标识默认的音序器。 详情请参考class description 。 </p></blockquote><blockquote><p>结果<br>默认音序器，连接到默认接收器<br>异常<br>MidiUnavailableException -如果序不可由于资源限制，或者没有 Receiver可通过任何安装 MidiDevice ，或无定序器安装在系统中。<br>另请参见：<br>getSequencer(boolean) ， getSynthesizer() ， getReceiver() </p></blockquote><pre><code class="hljs">try&#123; //危险动作&#125;catch(Exception ex)&#123;//尝试恢复&#125;</code></pre><p>在MusicTest1.java文件编译时出现报错<br>【报错】 javac的时候 中文注释报错<br>【解决方法】 第一 chcp 65001<br>第二 javac -encoding UTF-8 xxx.java  </p><h3 id="2-MIDI理解"><a href="#2-MIDI理解" class="headerlink" title="2. MIDI理解"></a>2. MIDI理解</h3><p>查看 MIDI文件夹&#x2F;MiniMiniMusicApp.Java注释</p><blockquote><p>midi文件有音乐的信息,但不具备声音本身,类似乐谱 -&gt; midi装置知道如何读取midi文件并加以播放-&gt; 喇叭发声</p></blockquote><pre><code class="hljs">/* * @Descripttion:  * @version:  * @Author: silas * @Date: 2022-03-10 20:01:45 * @LastEditors: silas * @LastEditTime: 2022-03-11 20:23:27 */import javax.sound.midi.*;//将midi的包import进去//midi文件有音乐的信息,但不具备声音本身,类似乐谱 -&gt; midi装置知道如何读取midi文件并加以播放-&gt; 喇叭发声public class MiniMiniMusicApp &#123;public static void main(String[] args)&#123;    MiniMiniMusicApp mini = new MiniMiniMusicApp();    mini.play();&#125;public void play()&#123;    try&#123;        //获得一个 sequencer 播放装置        Sequencer player = MidiSystem.getSequencer();        //MidiUnavailableException ex 此处getsequencer的异常时        player.open();//打开播放装置        //创建要播放的东西        Sequence seq = new Sequence(Sequence.PPQ, 4);//参数意义未知                //带有乐曲信息的记录        Track track = seq.createTrack();        //乐曲的音乐符等信息        ShortMessage a = new ShortMessage();//Massage描述做什么.MidiEvent描述什么时候做        a.setMessage(144, 1, 44, 100);//发出44分音符        MidiEvent noteon = new MidiEvent(a, 1);//在第一拍启动a这个massage        track.add(noteon);        /*        setMassage(144,1,44,100)        参数1 类型 144表示开启 128表示关闭        参数2 频道 1是吉他 2是Bass         参数3 音符 0~127 的是不同音高        参数4 音道 多大声音0~100        */        ShortMessage b = new ShortMessage();        b.setMessage(128, 1, 44, 100);        MidiEvent noteoff = new MidiEvent(b, 16);        track.add(noteoff);        player.setSequence(seq);//将sequence送到sequencer上        player.start();    &#125;catch(Exception ex)&#123;//此处用ex 父类来检测所有异常        ex.printStackTrace();    &#125;&#125;&#125;</code></pre><p>配合的有几个Mini播放器的实现</p><h2 id="第二部分-GUI"><a href="#第二部分-GUI" class="headerlink" title="第二部分 GUI"></a>第二部分 GUI</h2><h3 id="1-GUI理解"><a href="#1-GUI理解" class="headerlink" title="1. GUI理解"></a>1. GUI理解</h3><h4 id="1-窗口"><a href="#1-窗口" class="headerlink" title="(1)窗口"></a>(1)窗口</h4><pre><code class="hljs">public class SimpeGui1 &#123;/** * @param args */public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    JFrame frame = new JFrame();    JButton button = new JButton(&quot;click me &quot;);    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    frame.getContentPane().add(button);    frame.setSize(300, 300);    frame.setVisible(true);&#125;&#125;</code></pre><h4 id="2-button按键"><a href="#2-button按键" class="headerlink" title="(2)button按键"></a>(2)button按键</h4><pre><code class="hljs">public class SimpleGui1b implements ActionListener&#123;JButton button;/** * @param args */public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    SimpleGui1b gui = new SimpleGui1b();    gui.go();&#125;public void go() &#123;    JFrame frame = new JFrame();    button = new JButton(&quot;click me&quot;);        button.addActionListener(this);//向buttton注册        frame.getContentPane().add(BorderLayout.CENTER,button);      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    frame.setSize(300,300);    frame.setVisible(true);&#125;public void actionPerformed(ActionEvent event) &#123;    button.setText(&quot;i have been clicked&quot;);//实现interface上的方法 按钮会以actionevent对象作为参数来调用此方法    &#125;&#125;</code></pre><h3 id="2-GUI监听鼠标点击button并调用画笔"><a href="#2-GUI监听鼠标点击button并调用画笔" class="headerlink" title="2. GUI监听鼠标点击button并调用画笔"></a>2. GUI监听鼠标点击button并调用画笔</h3><p>创建窗口 -&gt; 创建button -&gt; button监听函数 -&gt; button监听到异常状态则实现方法 -&gt; 将buttton和画笔放在窗口上</p><pre><code class="hljs">public class SimpleGui3c implements ActionListener&#123;/** * @param args */JFrame frame;public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    SimpleGui3c gui3c = new SimpleGui3c();    gui3c.go();&#125;public void go() &#123;    frame = new JFrame();//创建窗口    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//在window关闭的时候结束程序        JButton button = new JButton(&quot;change colors&quot;);//创建按钮    button.addActionListener(this);//为按钮添加监听器 即对此按钮操作时会被检测到        MyDrawPanel1 drawPanel = new MyDrawPanel1();//创建自己的画笔        frame.getContentPane().add(BorderLayout.SOUTH,button);//将创建好的按钮添加到窗口    frame.getContentPane().add(BorderLayout.CENTER,drawPanel);//将创建的画笔添加到窗口        //窗口    //        north    //west  center  east    //        south        frame.setSize(300,300);//设置窗口大小    frame.setVisible(true);//显示窗口哦&#125;public void actionPerformed(ActionEvent event) &#123;    //实现interface上的方法 按钮会以actionevent对象作为参数来调用此方法    frame.repaint();//当点击按钮则新绘制窗口&#125;&#125;class MyDrawPanel1 extends JPanel    //此方法会在重新绘制frame的时候被调用&#123;public void  paintComponent(Graphics g)//实际是一个Graphic 2d对象&#123;    Graphics2D graphics2d = (Graphics2D) g;//将类型转换为2d    int green = (int)(Math.random()*255);    int blue = (int)(Math.random()*255);    int red = (int)(Math.random()*255);        Color startColor = new Color(red,green,blue);        green = (int)(Math.random()*255);    blue = (int)(Math.random()*255);    red = (int)(Math.random()*255);    Color endColor = new Color(red,green,blue);        GradientPaint gradientPaint=new GradientPaint(70, 70, startColor, 150,150,endColor);    //70,70 起点 开始颜色 150,150终点 最后颜色    graphics2d.setPaint(gradientPaint);    //将虚拟的笔刷换渐层    graphics2d.fillOval(70, 70, 100, 100);    //用目前的笔刷填满椭圆形的区域&#125;&#125;</code></pre><h3 id="3-多个按钮和控制器-内部类-接口-的方式实现多button对不同对象的调用修改"><a href="#3-多个按钮和控制器-内部类-接口-的方式实现多button对不同对象的调用修改" class="headerlink" title="3. 多个按钮和控制器 (内部类+接口)的方式实现多button对不同对象的调用修改"></a>3. 多个按钮和控制器 (内部类+接口)的方式实现多button对不同对象的调用修改</h3><pre><code class="hljs">public class twobutton &#123;/** * @param args */JFrame frame;JLabel lable;public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    twobutton twobn = new twobutton();    twobn.go();&#125;public void go() &#123;    frame = new JFrame();//创建窗口    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//在window关闭的时候结束程序        JButton button = new JButton(&quot;change colors&quot;);//创建按钮    button.addActionListener(new colorlisterner());//为按钮添加监听器 即对此按钮操作时会被检测到        JButton labButton = new JButton(&quot;change lable&quot;);    labButton.addActionListener(new lablelistener());        lable = new JLabel(&quot;i am a lable&quot;);    MyDrawPanel drawPanel = new MyDrawPanel();//创建自己的绘图程序        frame.getContentPane().add(BorderLayout.SOUTH,button);//将创建好的按钮添加到窗口    frame.getContentPane().add(BorderLayout.CENTER,drawPanel);//将创建的函数添加到窗口    frame.getContentPane().add(BorderLayout.EAST,labButton);    frame.getContentPane().add(BorderLayout.WEST,lable);    //窗口    //        north    //west  center  east    //        south        frame.setSize(500,500);//设置窗口大小    frame.setVisible(true);//显示窗口哦&#125;//    public void actionPerformed(ActionEvent event) &#123;//        //实现interface上的方法 按钮会以actionevent对象作为参数来调用此方法//        frame.repaint();//当点击按钮则新绘制窗口//    &#125; //     方法一 ://    此处由于两个按钮 ,如果都声明一样的方法  (如下) 则编译器无法分辨 哪个 所以不行的//    public void actionPerformed(ActionEvent event)&#123; fram.repaint()&#125;;//    public void actionPerformed(ActionEvent event)&#123;lable.settext(&quot;new test)&#125;;//    方法二:对两个按钮注册同一个监听接口 辨别来自哪个 ok但是不是面向对象的思想//    public void actionPerformed(ActionEvent event) &#123;//    //实现interface上的方法 按钮会以actionevent对象作为参数来调用此方法//    if(enent.getsource() == coloButton) frame.repaint()//当点击按钮则新绘制窗口//  else lable.setText(&quot;new&quot;);//    &#125; //    方法3:创建不同的actionlistener//    class colorbuttonlistener implements ActionListener//    &#123; public void actionPerformed(ActionEvent event) &#123;&#125;&#125;//    class lablebuttonlistener implements ActionListener//    &#123; public void actionPerformed(ActionEvent event) &#123;&#125;&#125;//这些类无法取到所需的变量//解决方法 : 内部类class colorlisterner implements ActionListener&#123;    public void actionPerformed(ActionEvent event)    &#123;        frame.repaint();    &#125;&#125;class lablelistener implements ActionListener&#123;    public void actionPerformed(ActionEvent event)    &#123;        lable.setText(&quot;ouch&quot;);    &#125;&#125;&#125;class MyDrawPanel extends JPanel    //此方法会在重新绘制frame的时候被调用&#123;public void  paintComponent(Graphics g)//实际是一个Graphic 2d对象&#123;    Graphics2D graphics2d = (Graphics2D) g;//将类型转换为2d    int green = (int)(Math.random()*255);    int blue = (int)(Math.random()*255);    int red = (int)(Math.random()*255);        Color startColor = new Color(red,green,blue);        green = (int)(Math.random()*255);    blue = (int)(Math.random()*255);    red = (int)(Math.random()*255);    Color endColor = new Color(red,green,blue);        GradientPaint gradientPaint=new GradientPaint(70, 70, startColor, 150,150,endColor);    //70,70 起点 开始颜色 150,150终点 最后颜色    graphics2d.setPaint(gradientPaint);    //将虚拟的笔刷换渐层     graphics2d.fillOval(70, 70, 100, 100);    //用目前的笔刷填满椭圆形的区域&#125;&#125;</code></pre><h2 id="第三部分-将GUI部分和MIDI结合起来"><a href="#第三部分-将GUI部分和MIDI结合起来" class="headerlink" title="第三部分 将GUI部分和MIDI结合起来"></a>第三部分 将GUI部分和MIDI结合起来</h2><h3 id="1-实现由MIDI主动驱动GUI随机生成的部件"><a href="#1-实现由MIDI主动驱动GUI随机生成的部件" class="headerlink" title="1.实现由MIDI主动驱动GUI随机生成的部件"></a>1.实现由MIDI主动驱动GUI随机生成的部件</h3><blockquote><p>实现方式:  </p><ul><li><p>MIDI在发声时,传出一个shormassage,而在声音添加的监听器 </p><blockquote><p>sequencer.addControllerEventListener(myDrawPanel,new int[] {127});<br> &#x2F;&#x2F;插入时间编号为127的自定义controllerEvent(176)不作任何事只是报告影评被播放,他的tick 和note on是同时进行 </p></blockquote></li><li><p>会将控制信息传到实现了控制接口的画笔类上  </p><blockquote><p>class MyDarwPanel extends JPanel implements ControllerEventListener  </p></blockquote></li><li><p>绘画类中有实现接口的函数  </p><blockquote><p>public void controlChange(ShortMessage eventMessage) {msg &#x3D; true;repaint();}</p></blockquote></li></ul><p>会实现绘画的调用</p></blockquote><h4 id="最终实现-跟着声音随机画图的MIDIplayer"><a href="#最终实现-跟着声音随机画图的MIDIplayer" class="headerlink" title="最终实现:跟着声音随机画图的MIDIplayer"></a>最终实现:跟着声音随机画图的MIDIplayer</h4><pre><code class="hljs">/** *  */package MIDIPlayer;import javax.sound.midi.*;import java.io.*;import javax.swing.*;import java.awt.*;/** * @author wenlo * */public class MiniMusicPlayer3 &#123;/** * @param args */static JFrame frame = new JFrame(&quot;my first music video&quot;);//创建窗口static MyDarwPanel myDrawPanel;//绘画类public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    MiniMusicPlayer3 miniMusicPlayer3 = new MiniMusicPlayer3();    miniMusicPlayer3.go();&#125;public void setUpGui() &#123;    myDrawPanel = new MyDarwPanel();    //创建绘画类实例    frame.setContentPane(myDrawPanel);    frame.setBounds(30,30,300,300);    frame.setVisible(true);&#125;public void go() &#123;    setUpGui();//初始化gui        try &#123;        Sequencer sequencer=MidiSystem.getSequencer();        sequencer.open();                sequencer.addControllerEventListener(myDrawPanel,new int[] &#123;127&#125;);//声音的contre给 绘画        Sequence sequence =new Sequence(Sequence.PPQ, 4);        Track track =sequence.createTrack();                int r =0;        for(int j = 0 ;j &lt; 60 ; j+=4)        &#123;            r = (int)((Math.random()*50)+1);            track.add(makeEvent(144, 1, r, 100, j));            track.add(makeEvent(176, 1, 127, 0, j));            //插入时间编号为127的自定义controllerEvent(176)不作任何事只是报告影评被播放,他的tick 和note on是同时进行            track.add(makeEvent(128, 1, r, 100, j+2));        &#125;                sequencer.setSequence(sequence);        sequencer.setTempoInBPM(120);        sequencer.start();            &#125; catch (Exception e) &#123;        // TODO: handle exception        e.printStackTrace();    &#125;&#125;public MidiEvent makeEvent(int comd,int chan,int one ,int two,int tick) &#123;//创建声音信息    MidiEvent event=null;    try &#123;        ShortMessage a=new ShortMessage();        a.setMessage(comd,chan,one,two);        event = new MidiEvent(a, tick);    &#125; catch (Exception e) &#123;        // TODO: handle exception    &#125;    return event;&#125;class MyDarwPanel extends JPanel implements ControllerEventListener&#123;//绘制类实现控制接口    boolean msg = false;        public void controlChange(ShortMessage eventMessage) &#123;        msg = true;        repaint();    &#125;    public void paintComponent(Graphics graphics) &#123;        if(msg) &#123;            Graphics2D graphics2d = (Graphics2D) graphics;                        int red = (int) (Math.random()*250);            int green = (int) (Math.random()*250);            int blue = (int) (Math.random()*250);                        graphics.setColor(new Color(red,green,blue));                        int hight = (int)((Math.random()*120)+10);            int width = (int)((Math.random()*120)+10);                        int x = (int)((Math.random()*40)+10);            int y = (int)((Math.random()*40)+10);                        graphics.fillRect(x, y, hight, width);            msg =false;        &#125;    &#125;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Java项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习-滑动窗口</title>
    <link href="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口。</p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><p>窗口有两类，一种是固定大小类的窗口，一类是大小动态变化的窗口。</p><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><p>利用滑动窗口获取平滑的数据，如一段连续时间的数据平均值，能够有更好的稳定性，如温度监测。</p><p>什么情况可以用滑动窗口来解决实际问题呢？</p><ul><li>一般给出的数据结构是数组或者字符串</li><li>求取某个子串或者子序列最长最短等最值问题或者求某个目标值时</li><li>该问题本身可以通过暴力求解</li></ul><h2 id="4-算法思想"><a href="#4-算法思想" class="headerlink" title="4.算法思想"></a>4.算法思想</h2><ol><li>在序列中使用双指针中的左右指针技巧，初始化 left &#x3D; right &#x3D; 0，把索引闭区间 [left, right] 称为一个窗口。</li></ol><p><img src="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%BB%91%E5%8A%A8%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.png"></p><ol start="2"><li>先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的序列符合要求。</li></ol><p><img src="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E7%AA%97%E5%8F%A3%E5%85%83%E7%B4%A0%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6.png"><br>3. 此时，停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的序列不再符合要求。同时，每次增加 left前，都要更新一轮结果。</p><p><img src="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8.png"><br>4. 重复第 2 和第 3 步，直到 right 到达序列的尽头。<br>思路其实很简单：第 2 步相当于在寻找一个可行解，然后第 3 步在优化这个可行解，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><h2 id="5-算法模板"><a href="#5-算法模板" class="headerlink" title="5.算法模板"></a>5.算法模板</h2><h3 id="1-单循环–适用于固定窗口大小"><a href="#1-单循环–适用于固定窗口大小" class="headerlink" title="(1)单循环–适用于固定窗口大小"></a>(1)单循环–适用于固定窗口大小</h3><pre><code class="hljs">def template():# 初始化滑动窗口两端left = right = 0# 序列及序列长度seq, seq_len = xx, xx# 滑动窗口序列slide_win = []# 结果值rst = xxwhile right &lt; seq_len:    slide_win.append(seq[right])    # 还没找到一个可行解    if not avaliable(slide_win):        # 扩大窗口        right += 1    else:        # 找到一个可行解，更新结果值        rst = update()        # 缩小窗口        left += 1</code></pre><h3 id="2-双层循环-–-适用于动态窗口"><a href="#2-双层循环-–-适用于动态窗口" class="headerlink" title="(2)双层循环 – 适用于动态窗口"></a>(2)双层循环 – 适用于动态窗口</h3><pre><code class="hljs">def template():# 初始化滑动窗口两端left = right = 0# 序列及序列长度seq, seq_len = xx, xx# 滑动窗口序列slide_win = []# 结果值rst = xxwhile right &lt; seq_len:    slide_win.append(seq[right])    # 还没找到一个可行解    if not avaliable(slide_win):        # 扩大窗口        right += 1        continue    # 循环更新可行解    while avaliable(slide_win):        # 找到一个可行解，更新结果值        rst = update()        # 缩小窗口        left += 1</code></pre><h2 id="6-实战代码"><a href="#6-实战代码" class="headerlink" title="6.实战代码"></a>6.实战代码</h2><h3 id="1-固定窗口-LC438-找到字符串中所有字母异位词"><a href="#1-固定窗口-LC438-找到字符串中所有字母异位词" class="headerlink" title="(1) 固定窗口 LC438_找到字符串中所有字母异位词"></a>(1) 固定窗口 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">LC438_找到字符串中所有字母异位词</a></h3><pre><code class="hljs">vector&lt;int&gt; findAnagrams(string s, string p) &#123;//窗口:字母和p相同的字串  窗口大小 p的长度//当窗口小于n 则first++//当窗口大于等于n  则second++////异位词即字母出现相同vector&lt;int&gt; ans=vector&lt;int&gt;(26,0);vector&lt;int&gt; ver=vector&lt;int&gt;(26,0);vector&lt;int&gt; res;    for(int i = 0 ;i &lt; p.size();i++)    &#123;        ans[p[i]-&#39;a&#39;]++;    &#125;    for(int i = 0;i &lt;s.size();i++ )    &#123;        ver[s[i]-&#39;a&#39;]++;        if(i &gt;= p.size()) ver[s[i-p.size()]-&#39;a&#39;]--;        if(ans == ver) res.push_back(i-p.size()+1);    &#125;    return res;&#125;</code></pre><h3 id="2-动态窗口-LC76-最小覆盖子串"><a href="#2-动态窗口-LC76-最小覆盖子串" class="headerlink" title="(2) 动态窗口 LC76_最小覆盖子串"></a>(2) 动态窗口 <a href="https://leetcode-cn.com/problems/minimum-window-substring/">LC76_最小覆盖子串</a></h3><pre><code class="hljs">string minWindow(string s, string t)&#123;//窗口:s字串的子串能覆盖住t  窗口大小 至少为t.length()//当窗口小于 t.length() 则first++//当窗口大于等于t.length()  若满足则second++//覆盖即 s的字符出现数 &gt;= p的字符出现数//当使用unordermap 来存储&lt;字符,字符出现次数&gt;string result;if(s.empty()||t.empty()) return result;unordered_map&lt;char,int&gt; map;unordered_map&lt;char,int&gt; window;for(char c:t)&#123;    map[c]++;&#125;int minlength = INT_MAX;int lettercount =0;for(int slow = 0 ,fast =0;fast &lt; s.length();fast++)&#123;    char c =s[fast];    if(map.find(c) != map.end())//若此字符是目标串出现过的字符    &#123;        window[c]++;        if(window[c]&lt;= map[c])        lettercount++;//第一次遇到时 让count++    &#125;    if(lettercount &gt;= t.length())//全部的字符已经覆盖到了    &#123;        while(map.find(s[slow])==map.end() || window[slow]&gt; map[slow])    //slow的字符没在目标串中出现的字母或者字符出现次数多与需要    //在满足基恩本条件下缩小窗口        &#123;            window[s[slow]]--;            slow++;        &#125;        if((fast - slow + 1 )&lt; minlength)        &#123;            minlength = fast-slow+1;            result = s.substr(slow,minlength);        &#125;    &#125;&#125;return result;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习(第二部分)-数组</title>
    <link href="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%95%B0%E7%BB%84/"/>
    <url>/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="第二部分-数据结构-数组"><a href="#第二部分-数据结构-数组" class="headerlink" title="第二部分 数据结构 - 数组"></a>第二部分 数据结构 - 数组</h1><h2 id="一-数组理论基础"><a href="#一-数组理论基础" class="headerlink" title="一. 数组理论基础"></a>一. 数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong>  </p><ul><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的</li><li>正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。数组的元素是不能删的，只能覆盖。<h2 id="二-数组问题举例"><a href="#二-数组问题举例" class="headerlink" title="二. 数组问题举例"></a>二. 数组问题举例</h2></li></ul><h3 id="1-有序数组的查找-–二分法"><a href="#1-有序数组的查找-–二分法" class="headerlink" title="1.有序数组的查找 –二分法"></a>1.有序数组的查找 –二分法</h3><pre><code class="hljs">int binary1(vector&lt;int&gt; &amp;num, int target, int low, int high)&#123;//递归if (high &gt;= low)&#123;    int mid = low + (high - low)/ 2;    if (num.at(mid) == target)        return mid;    else if (num.at(mid) &gt; target)        return binary1(num, target, low, mid - 1);    return binary1(num, target, mid + 1, high);&#125;return -1;&#125;int binary2(vector&lt;int&gt; &amp;num, int target)&#123;int low = 0, high = num.size() - 1;int mid;while (low &lt;= high)&#123;    /* code */    mid = low + (high - low) &gt;&gt; 1;    if (num.at(mid) == target)        return mid;    if (num.at(mid) &gt; target)        high = mid - 1;    else        low = mid + 1;&#125;return -1;&#125;int binary3(vector&lt;int&gt; &amp;num, int target)&#123;int low = 0, high = num.size();while (low &lt; high)&#123;    /* code */    int mid = low + (high - low) &gt;&gt; 1;    if (num.at(mid) == target)        return mid;    if (num.at(mid) &gt; target)        high = mid;    else        low = mid + 1;&#125;return -1;&#125;</code></pre><p>理解二分法对于区间的划分来规定边界情况<br>[low,high]  边界设为 low &lt;&#x3D; high 下一次选取[low,mid-1]和[mid+1,low]<br>[low,high) 边界设为 low&lt;high 下一次选取[low,mid) [mid,high) </p><h3 id="2-移除元素-x2F-插入元素"><a href="#2-移除元素-x2F-插入元素" class="headerlink" title="2.移除元素&#x2F;插入元素"></a>2.移除元素&#x2F;插入元素</h3><p> 数组需要大量的移动数据,在考虑时可以使用两个指针(下标),来记录应当保留(移动的)情况  快慢指针</p><blockquote><p>LeetCode N27_移除元素</p></blockquote><pre><code class="hljs">int removeElement(vector&lt;int&gt;&amp; nums, int val)&#123;int first,second;first = 0;for(second =0 ; second &lt; nums.size();second++)&#123;if(nums.at(second)!=val)nums[first++]=nums[second];&#125;return first;&#125;</code></pre><h3 id="3-通过-长度最小的子树组-理解滑动窗口"><a href="#3-通过-长度最小的子树组-理解滑动窗口" class="headerlink" title="3.通过 长度最小的子树组 理解滑动窗口"></a>3.通过 长度最小的子树组 理解滑动窗口</h3><blockquote><p>理解 滑动窗口<br>(1)滑动窗口内的元素是什么?<br>(2)如何移动滑动窗口起始位置?<br>(3)如何滑动窗口终止位置?</p></blockquote><h4 id="1-滑动窗口算法"><a href="#1-滑动窗口算法" class="headerlink" title="(1) 滑动窗口算法"></a>(1) 滑动窗口算法</h4><p>滑动窗口，顾名思义，就是有一个大小可变的窗口，左右两端方向一致的向前滑动（右端固定，左端滑动；左端固定，右端滑动）。可以想象成队列，一端在push元素，另一端在pop元素</p><h4 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="(2)适用范围"></a>(2)适用范围</h4><ol><li>一般是字符串或者列表</li><li>一般是要求最值（最大长度，最短长度等等）或者子序列</li></ol><h4 id="3-算法模板"><a href="#3-算法模板" class="headerlink" title="(3) 算法模板"></a>(3) 算法模板</h4><pre><code class="hljs">int left = 0,right =0;while(right指针未越界)&#123;  char ch = arr[right++];  //右指针移动，更新窗口  ...    //窗口数据满足条件 对于固定窗口而言，就是窗口的大小&gt;=固定值；对于动态窗口，就是从left出发，窗口不断扩充，第一次满足题意的位置  while(窗口数据满足条件)&#123;      //记录或者更新全局数据      ...            //右指针不动，左指针开始移动一位      char tmp = arr[left++];            //左指针移动，窗口缩小，更新窗口数据      ...  &#125;  //返回结果  ...&#125;</code></pre><h4 id="4-结论"><a href="#4-结论" class="headerlink" title="(4) 结论"></a>(4) 结论</h4><ul><li>滑动窗口算法就是用以解决数组&#x2F;字符串的子元素问题</li><li>滑动窗口算法可以将嵌套的for循环问题，转换为单循环问题，降低时间复杂度</li></ul><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="(5) 实例"></a>(5) 实例</h4><blockquote><p>LeetCode N209_长度最小的子树组</p></blockquote><pre><code class="hljs">int minSubArrayLen1(int target, vector&lt;int&gt;&amp; nums)&#123;int sum,res,len,i,j;res = INT32_MAX;for(i=0;i&lt;nums.size();i++)&#123;    sum = 0;    for(j = i ; j &lt; nums.size();j++)    &#123;        sum+=nums[j];        if(sum&gt;=target)        &#123;            len = j - i +1;            res = (res&lt;len)?res:len;            break;        &#125;    &#125;&#125;res = (res==INT32_MAX)?0:res;return res;&#125;int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums)&#123;//滑动窗口内的元素 ： 和大于等于target的子数组//滑动起点 ： i指针 当出现sum &gt;target 是 sum-=nums[i++]//滑动重点 ： j指针当前指针int res,sum,i,j,len;res=INT32_MAX;sum = 0;len = 0;i=0;for(j=0;j&lt;nums.size();j++)&#123;    sum+=nums.at(j);    while (sum&gt;=target)    &#123;        len = j -i+1;        res =(res&lt;len)?res:len;        sum-=nums.at(i++);        /* code */    &#125;&#125;return res==INT32_MAX?0:res;&#125;</code></pre><h3 id="4-循环情况要理清思路"><a href="#4-循环情况要理清思路" class="headerlink" title="4. 循环情况要理清思路"></a>4. 循环情况要理清思路</h3><blockquote><p>LeetCode N59_螺旋矩阵2 </p></blockquote><pre><code class="hljs">vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;vector&lt;vector&lt;int&gt;&gt; num(n,vector&lt;int&gt; (n,0));int len = n-1;int mid = n/2;int loop = n/2;int offset = 1;int stx,sty,i,j;int count =1;stx=sty=0;for(int k = 0 ; k &lt; loop ;k++)&#123;    i=stx;    j=sty;    //left -&gt; right    for(j = sty ; j &lt; sty + n - offset ;j++ )    &#123;        num[i][j] = count++;    &#125;    //up -&gt; down    for(i = stx; i &lt; stx+n-offset;i++)    &#123;        num[i][j] = count++;    &#125;    //right -&gt; left    for(;j&gt;sty;j--)    &#123;        num[i][j] =count++;    &#125;    for(;i&gt;stx;i--)    &#123;        num[i][j]= count++;    &#125;    stx ++;sty++;    offset+=2;&#125;if(n&amp;0x01)&#123;    num[mid][mid] = count;&#125;return num;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习(第一部分)-性能分析</title>
    <link href="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="算法学习-第一部分"><a href="#算法学习-第一部分" class="headerlink" title="算法学习 (第一部分)"></a>算法学习 (第一部分)</h1><h2 id="第一部分-性能分析"><a href="#第一部分-性能分析" class="headerlink" title="第一部分 性能分析"></a>第一部分 性能分析</h2><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h3><p>  问题计算所需时间同问题规模n的关系,采用大O表示法.</p><blockquote><p>常数阶O(1)-&gt; 对数阶O(log2n)-&gt; 线性阶O(n) -&gt;线性对数阶O(nlog2n)-&gt;平方阶O(n2)-&gt;立方阶O(n3),…，-&gt; k次方阶O(nk)-&gt;指数阶O(2n)。 </p></blockquote><p>随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p><h4 id="1-举个例子"><a href="#1-举个例子" class="headerlink" title="(1).举个例子"></a>(1).举个例子</h4><p>求:x的n次方</p><pre><code class="hljs">int function1(int x,int n)&#123;    int result = 1;    for(int i = 0 ;i &lt;ｎ；ｉ＋＋）    ｛          result *= x;        &#125;    return result;&#125;int function2(int x,int n)&#123;    if(n == 0) return 1;    return function2(x,n-1);&#125;int function3(int x,int n)&#123;    if(n == 0) return 1;    if(n%2 == 1) return function3(x,n/2)*function3(x,n/2)*x;    return function3(x,n/2)*function3(x,n/2);&#125;int function4(int x,int n)&#123;    if(n == 0) return 1;    int t = function4(x,n/2)    if(n%2==1) return t*t*x;    return t*t;&#125;</code></pre><p>可以看到不同的方法可以使软件的时间空间复杂度截然不同</p><h3 id="2-c-的内存管理"><a href="#2-c-的内存管理" class="headerlink" title="2.c++的内存管理"></a>2.c++的内存管理</h3><h4 id="1-理解c-的内存管理"><a href="#1-理解c-的内存管理" class="headerlink" title="(1)理解c++的内存管理"></a>(1)理解c++的内存管理</h4><p><img src="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/p1.png"></p><h4 id="2-理解为何需要内存对齐"><a href="#2-理解为何需要内存对齐" class="headerlink" title="(2)理解为何需要内存对齐?"></a>(2)理解为何需要内存对齐?</h4><ul><li>不是所有的硬件平台都允许访问任意内存地址的数据,某些平台只能在一些地址获取特定类型的数据,否则抛出硬件异常,为了同一程序在不同平台运行,需要内存对齐</li><li>对齐内存后虽然会损失一部分空间,可是能极大提升cpu访问内存的速率(具体原因理解cpu是按块读取内存的,对齐使访问更直接)</li></ul><h3 id="3-空间复杂度"><a href="#3-空间复杂度" class="headerlink" title="3.空间复杂度"></a>3.空间复杂度</h3><p>同理 所需空间同问题规模的关系也可以使用大o表示法,注意空间复杂度为O(1)也成为就地执行.一般的我们使用空间来换取时间.</p><h4 id="1-举个例子-1"><a href="#1-举个例子-1" class="headerlink" title="(1) 举个例子"></a>(1) 举个例子</h4><pre><code class="hljs">int feibo1(int n)&#123;//完全的递归if(n&lt;=0) return 0;if(n==1||n==2) return 1;if(n==3) return 2;else return feibo1(n-1)+feibo1(n-2);&#125;int feibo2(int first,int second,int n)&#123;//精简解法 应当理解if(n&lt;=0) return 0;if(n&lt;3) return 1;if(n ==3) return first+second;else return feibo2(second,first+second,n-1);&#125;int feibo3(int n)&#123;//使用数组存储if(n&lt;=0) return 0;if(n==1||n==2) return 1;vector&lt;int&gt; num&#123;1,1&#125;;num.reserve(n+2);vector&lt;int&gt;::iterator it;for(int i = 0; i &lt; n-2 ;i++)&#123;num.push_back(num.at(i)+num.at(i+1));&#125;return num.back();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试问题</title>
    <link href="/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="c-x2F-c-面试笔试"><a href="#c-x2F-c-面试笔试" class="headerlink" title="c&#x2F; c++面试笔试"></a>c&#x2F; c++面试笔试</h1><h3 id="1-c-的知道哪些C语言字符串拷贝的方法"><a href="#1-c-的知道哪些C语言字符串拷贝的方法" class="headerlink" title="1.c++的知道哪些C语言字符串拷贝的方法"></a>1.c++的知道哪些C语言字符串拷贝的方法</h3><h4 id="1-第一个strcpy"><a href="#1-第一个strcpy" class="headerlink" title="(1) 第一个strcpy()"></a>(1) 第一个strcpy()</h4><p>使用头文件：#include &lt;string.h&gt;  </p><pre><code class="hljs">定义：char *strcpy(char *dest, const char *src);参数：destinin：目标字符数组；source：源字符数组；函数说明：  strcpy()会将参数src 字符串拷贝至参数dest 所指的地址。 用于对字符串进行复制，识别到字符串的结束符号‘\0’自动停止返回值：返回参数dest 的字符串起始地址。注意：参数 dest 的内存空间要足够大，否则拷贝可能会造成缓冲溢出。strcpy() 在复制结束后会添加结束符\0，这点和strncpy()不同</code></pre><h4 id="2-memcpy"><a href="#2-memcpy" class="headerlink" title="(2) memcpy()"></a>(2) memcpy()</h4><pre><code class="hljs">使用头文件：C语言：#include &lt;string.h&gt; C++：#include&lt;cstring&gt;定义：void memcpy(void *dest, const void *src, size_t n);参数：destinin：目标地址；source：源地址；n：复制的字节长度。函数说明：memcpy()复制 src 所指的内存数据的 n 个字节到 dest所指的内存地址上。也就是从源地址复制n 个字节到目标地址</code></pre><p>第一个和第二个指针都是void型且第二个指针不能被修改，第三个参数是需要拷贝的内存长度按字节记。</p><p>返回值：返回指向 dest 的指针。返回的指针类型是void。</p><p>注意：</p><p><strong>memcpy()并不限制被复制的数据类型，只是逐字节地进行复制，任何数据类型都可以进行复制，例如字符数组、整型、结构体、类等</strong></p><p>memcpy() 会完整的复制 num个字节，<strong>不会遇到‘\0’而结束</strong>，这点与 strcpy() 不同</p><p>dest 和 src所指的内存空间地址不能重叠</p><p>参数 dest 的内存空间要足够大，起码要大于等于 num个字节</p><p><strong>通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</strong></p><h4 id="3-strncpy"><a href="#3-strncpy" class="headerlink" title="(3)strncpy()"></a>(3)strncpy()</h4><pre><code class="hljs">使用头文件：#include &lt;string.h&gt;定义：char *strncpy(char *dest, const char *src, size_t len);参数：destinin：目标字符数组；source：源字符数组；len：复制的字符串长度。函数说明：strncpy()复制字符串 src 的前 len 个字节到 dest所指的内存地址上。返回值：返回字符串dest</code></pre><p>注意：</p><ul><li><p>strncpy()在复制结束后不会向dest结尾添加’\0’结束符 这个是很重要的一个点，要记住</p></li><li><p>如果source(源字符数组)的长度&gt;复制的字符串数len，则只复制source(源字符数组)的前len个字符，不会自动添加结束符\0 </p></li><li><p>如果source(源字符数组)的长度&lt;复制的字符串数len，则以NULL填充dest(目标字符数组),直到复制完n个字节</p></li><li><p>参数 dest 的内存空间要足够大，起码要大于等于 num个字节</p></li><li><p>在使用strncpy()的时候，拷贝长度最好为strlen(src)+1，以保证最后的结束符\0也能被复制</p><h4 id="3-memmove"><a href="#3-memmove" class="headerlink" title="(3) memmove()"></a>(3) memmove()</h4><p>  使用头文件：#include &lt;string.h&gt;</p><p>  定义：void <em>memmove( void</em> dest, const void* src, size_t count );</p><p>  参数：</p><p>  destinin：目标地址；<br>  source：源地址；<br>  count：复制的字节长度。</p></li></ul><p>函数说明：memmove()复制 src 所指的内存数据的 n 个字节到 dest所指的内存地址上。也就是从源地址复制n 个字节到目标地址。<br><strong>如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。</strong></p><h3 id="2-new-和-malloc的区别"><a href="#2-new-和-malloc的区别" class="headerlink" title="2.new 和 malloc的区别"></a>2.new 和 malloc的区别</h3><h4 id="1-申请的内存所在位置"><a href="#1-申请的内存所在位置" class="headerlink" title="(1). 申请的内存所在位置"></a>(1). 申请的内存所在位置</h4><p> new操作符从自由存储区（free store）上为对象动态分配内存空间，<br> malloc函数从堆上动态分配内存。<br> 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p><p><strong>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</strong></p><h4 id="2-返回类型安全性"><a href="#2-返回类型安全性" class="headerlink" title="(2).返回类型安全性"></a>(2).返回类型安全性</h4><p><strong>new操作符内存分配成功时，返回的是对象类型的指针</strong>，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。<br><strong>而malloc内存分配成功则是返回void 星</strong> ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p><h4 id="3-内存分配失败时的返回值"><a href="#3-内存分配失败时的返回值" class="headerlink" title="(3).内存分配失败时的返回值"></a>(3).内存分配失败时的返回值</h4><p><strong>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</strong></p><pre><code class="hljs">try&#123;int *a = new int();&#125;catch (bad_alloc)&#123;...&#125;</code></pre><p>如果你想顺便了解下异常基础，可以看<a href="http://www.cnblogs.com/QG-whz/p/5136883.html">http://www.cnblogs.com/QG-whz/p/5136883.html</a> C++ 异常机制分析。</p><h4 id="4-是否需要指定内存大小"><a href="#4-是否需要指定内存大小" class="headerlink" title="(4).是否需要指定内存大小"></a>(4).是否需要指定内存大小</h4><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p><h4 id="5-是否调用构造函数-x2F-析构函数"><a href="#5-是否调用构造函数-x2F-析构函数" class="headerlink" title="(5).是否调用构造函数&#x2F;析构函数"></a>(5).是否调用构造函数&#x2F;析构函数</h4><p>使用new操作符来分配对象内存时会经历三个步骤：</p><pre><code class="hljs">第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。第三部：对象构造完成后，返回一个指向该对象的指针。</code></pre><p>使用delete操作符来释放对象内存时会经历两个步骤：</p><pre><code class="hljs">第一步：调用对象的析构函数。第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。  </code></pre><p>总之来说，<strong>new&#x2F;delete会调用对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。而malloc则不会。</strong></p><h4 id="6-对数组的处理"><a href="#6-对数组的处理" class="headerlink" title="(6).对数组的处理"></a>(6).对数组的处理</h4><p>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。</p><ul><li><p>注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p></li><li><p>至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p></li></ul><h4 id="7-new与malloc是否可以相互调用"><a href="#7-new与malloc是否可以相互调用" class="headerlink" title="(7).new与malloc是否可以相互调用"></a>(7).new与malloc是否可以相互调用</h4><p>operator new &#x2F;operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new &#x2F;operator delete 的一种简单方式，其他版本也与之类似：</p><h4 id="8-是否可以被重载"><a href="#8-是否可以被重载" class="headerlink" title="(8).是否可以被重载"></a>(8).是否可以被重载</h4><p>opeartor new &#x2F;operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：而malloc&#x2F;free并不允许重载。</p><h4 id="9-能够直观地重新分配内存"><a href="#9-能够直观地重新分配内存" class="headerlink" title="(9). 能够直观地重新分配内存"></a>(9). 能够直观地重新分配内存</h4><p>使用malloc分配的内存后，如果在使用过程中发现内存不足，<strong>可以使用realloc函数进行内存重新分配实现内存的扩充</strong>。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p><p>new没有这样直观的配套设施来扩充内存。</p><h4 id="10-客户处理内存分配不足"><a href="#10-客户处理内存分配不足" class="headerlink" title="(10). 客户处理内存分配不足"></a>(10). 客户处理内存分配不足</h4><p>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p><h3 id="3-unix-的初始化和启动"><a href="#3-unix-的初始化和启动" class="headerlink" title="3. unix 的初始化和启动"></a>3. unix 的初始化和启动</h3><h4 id="1-unix系统的初始引导过程"><a href="#1-unix系统的初始引导过程" class="headerlink" title="(1)unix系统的初始引导过程"></a>(1)unix系统的初始引导过程</h4><pre><code class="hljs">unix从硬件加电到--&gt;ROM BIOS（检查硬件系统的配置，找到硬盘0号扇区）--&gt;将0号扇区读入内存</code></pre><h4 id="2-unix系统的初始化"><a href="#2-unix系统的初始化" class="headerlink" title="(2)unix系统的初始化"></a>(2)unix系统的初始化</h4><pre><code class="hljs">ROM BIOS --&gt; mboot/pboot --&gt;boot --&gt;stand/unix --&gt;init0 --&gt;init1  init -- RC.sysint -- rc.x --login在/etc/inittab 中获取initdefault值进入默认的运行级Unix的8个运行级0 停止操作系统1 单用户2 多用户3 加网络4 多用户配置环境5固件诊断，关闭所有服务，关机6 重启S/s 安装、root目录外 其他目录不安装，运行系统内部程序，单用户Abc 伪运行级 运行用户自定义出的程序系统的运行级不会发生变化</code></pre><p>&#x2F;etc&#x2F;RC N N为上述1~6</p><ul><li><p>检查修复root文件系统  </p></li><li><p>设置内部时钟</p></li><li><p>清理和安装所有文件系统</p></li><li><p>清理临时文件 &#x2F;tnp和&#x2F;var&#x2F;tmp</p></li><li><p>设置网络端口、接口、路由</p></li><li><p>启动日志文件调度进程syslogd</p></li><li><p>后台作业调度程序cron</p></li><li><p>启动必要的终端服务进程或应用特定的服务进程</p></li><li><p>用户注册程序</p></li></ul><h4 id="3-unix的启动顺序"><a href="#3-unix的启动顺序" class="headerlink" title="(3)unix的启动顺序"></a>(3)unix的启动顺序</h4><p>通过&#x2F;boot&#x2F;vm进行启动 vmlinuz</p><p>init &#x2F;etc&#x2F;inittab</p><p>启动相应的脚本，并且打开终端</p><pre><code class="hljs">rc.sysinitrc.d(里面的脚本）rc.local</code></pre><p>启动login登录界面 login</p><p>在用户登录的时候执行sh脚本的顺序(每次登录的时候都会完全执行的)</p><pre><code class="hljs">/etc/profile.d/file/etc/profile/etc/bashrc/root/.bashrc/root/.bash_profile</code></pre><h3 id="4-linux系统初始化和启动服务"><a href="#4-linux系统初始化和启动服务" class="headerlink" title="4. linux系统初始化和启动服务"></a>4. linux系统初始化和启动服务</h3><p>linux启动服务详见:<a href="https://blog.csdn.net/chinaren0001/article/details/6901454?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.queryctrv2&spm=1001.2101.3001.4242.1&utm_relevant_index=3" title="Linux如何初始化和启动服务">https://blog.csdn.net/chinaren0001/article/details/6901454?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_title~default-0.queryctrv2&amp;spm&#x3D;1001.2101.3001.4242.1&amp;utm_relevant_index&#x3D;3</a><br>Linux 系统启动过程</p><p>linux启动时我们会看到许多启动信息。</p><p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：  </p><pre><code class="hljs">操作系统--&gt; /boot(MBR)--&gt;init进程--&gt;运行级别(在/etc/inittab文件中)--&gt;初始化系统(/etc/RC.d/RC.sysint) --&gt; /etc/rc.d/rc x.d(根据载入的run level值载入对应目录的程序,决定开启哪些服务)--&gt;/sbin/minggetty(启动六个虚拟控制台)--&gt;用户登录系统(login)内核的引导。运行init。系统初始化。建立终端 。用户登录系统。</code></pre><h4 id="1-BIOS–-gt-MBR–-gt-KERNEL–-gt-INIT进程-一切进程的起点"><a href="#1-BIOS–-gt-MBR–-gt-KERNEL–-gt-INIT进程-一切进程的起点" class="headerlink" title="(1) BIOS–&gt;MBR–&gt;KERNEL–&gt;INIT进程(一切进程的起点)"></a>(1) BIOS–&gt;MBR–&gt;KERNEL–&gt;INIT进程(一切进程的起点)</h4><ol><li><p>当 电脑一打开 电源时电脑就会进入BIOS（BIOS的工作主要是检测一些硬件设备）；</p></li><li><p>检测完后会进入MBR也就是boot loader（MBR位于硬盘的第一个扇区总共512bytes，其中前446bytes里面的编码是在选择引导分区也就是决定要由哪个分区来引导）；</p></li><li><p>载入系统的Kernel(核心)，在Kernel里主要是载入电脑设备的驱动程序，以便可以控制电脑上的设备，并且以只读方式来挂载根目录，也就是一 开始只能读取到根目录所对应的那个分区，所以&#x2F;etc、&#x2F;bin、&#x2F;sbin、&#x2F;dev、&#x2F;lib这五个目录必须同根目录在一个分区中；</p></li><li><p>最后启动init这个程序，所以init这个程序的进程编号为1，是Linux中第一个执行的程序；</p></li></ol><p>init这个程序会根据 Run level来执行以下这些程序：</p><pre><code class="hljs">·/etc/rc.d/rc.sysinit;  ·/etc/rc.d/rc 和 etc/rc.d/rc?.d/  ·/etc/rc.d/rc.local  </code></pre><h4 id="2-介绍-x2F-etc-x2F-rc-d-x2F-rc-sysinit-这个程序主要做哪些工作（init初始化流程第二步）"><a href="#2-介绍-x2F-etc-x2F-rc-d-x2F-rc-sysinit-这个程序主要做哪些工作（init初始化流程第二步）" class="headerlink" title="(2) 介绍 &#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit 这个程序主要做哪些工作（init初始化流程第二步）"></a>(2) 介绍 &#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit 这个程序主要做哪些工作（init初始化流程第二步）</h4><ol><li>启动 udev ，也就是启用热插拔的设备，例如：USB，并且也会启动SELinux；  </li><li>会把kernel的参数设定在&#x2F;etc&#x2F;sysctl.conf配置文件里；这个配置文件下下单元详细说明；  </li><li>设定系统时间；  </li><li>载入 keymaps 设定， keymap设定是在定义 键盘，这样电脑开机时才能找到相对应的键盘设定；  </li><li>启用swap这个虚拟内存的分区；  </li><li>设定主机名称，主机名称设定在 &#x2F;etc&#x2F;sysconfig&#x2F;network 配置文件中的 HOSTNAME&#x3D; 项下；  </li><li>检查根目录有没有问题，并且重新挂载成为可读可写的状态；  </li><li>启用RAID磁盘阵列，以及LVM的设备；</li><li>启用磁盘配额的功能，就是限制使用者最多可以使用多少硬盘空间；  </li><li>检查其它的文件系统，并且把它们挂载进来；  </li><li>最后会清除被修改过的locks及PID files，其实就是清除一些开机时的缓存文件，以及一些没有用的信息及文件；</li></ol><h3 id="5-三次握手-和四次挥手"><a href="#5-三次握手-和四次挥手" class="headerlink" title="5.三次握手 和四次挥手"></a>5.三次握手 和四次挥手</h3><p>详解看这个 结合计算机网络 408 教材<br><a href="https://blog.csdn.net/qq_44443986/article/details/115966274?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164644652416781685335366%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164644652416781685335366&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115966274.pc_search_result_control_group&utm_term=tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B&spm=1018.2226.3001.4187" title="三次握手和四次挥手详解">https://blog.csdn.net/qq_44443986&#x2F;article&#x2F;details&#x2F;115966274?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522164644652416781685335366%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id&#x3D;164644652416781685335366&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>top_positive~default-1-115966274.pc_search_result_control_group&amp;utm_term&#x3D;tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B&amp;spm&#x3D;1018.2226.3001.4187</a></p><h3 id="6-操作系统内存管理"><a href="#6-操作系统内存管理" class="headerlink" title="6.操作系统内存管理"></a>6.操作系统内存管理</h3><p>分段 分页 段页式</p><h3 id="7-new-的底层实现"><a href="#7-new-的底层实现" class="headerlink" title="7.new 的底层实现"></a>7.new 的底层实现</h3><p>operator_num malloc </p><h3 id="8-stl的vector-和-map-x2F-set-无序的map怎么排序"><a href="#8-stl的vector-和-map-x2F-set-无序的map怎么排序" class="headerlink" title="8.stl的vector 和 map&#x2F;set 无序的map怎么排序"></a>8.stl的vector 和 map&#x2F;set 无序的map怎么排序</h3><p>key 和 value 对键值和value的排序通过修改compare的函数</p><h3 id="9-多线程-的同步方式-多进程的-通信方式"><a href="#9-多线程-的同步方式-多进程的-通信方式" class="headerlink" title="9. 多线程 的同步方式,多进程的 通信方式"></a>9. 多线程 的同步方式,多进程的 通信方式</h3><h4 id="1-进程间通讯："><a href="#1-进程间通讯：" class="headerlink" title="(1) 进程间通讯："></a>(1) 进程间通讯：</h4><ol><li><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p></li><li><p>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p></li><li><p>高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p></li><li><p>信号量( semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p></li><li><p>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></li><li><p>共享内存( sharedmemory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p></li><li><p>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p></li></ol><p>注意：临界区则是一种概念，指的是访问公共资源的程序片段，并不是一种通信方式。</p><h4 id="2-线程通讯："><a href="#2-线程通讯：" class="headerlink" title="(2) 线程通讯："></a>(2) 线程通讯：</h4><ol><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。  </li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。    </li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。  </li><li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量  </li><li>信号机制(Signal)： 类似进程间的信号处理</li></ol><p><strong>提问：互斥锁与信号量的区别？</strong><br>答：互斥锁用于线程的互斥，信号量用于线程的同步。这是互斥锁和信号量的根本区别，也就是互斥和同步之间的区别。同时互斥锁的作用域仅仅在于线程，信号量可以作用于线程和进程。</p><h3 id="10-虚函数-虚函数表-虚函数指针"><a href="#10-虚函数-虚函数表-虚函数指针" class="headerlink" title="10 .虚函数  虚函数表 虚函数指针"></a>10 .虚函数  虚函数表 虚函数指针</h3><p>(1)父类的析构函数不是虚函数会怎样?<br>(2)所有的函数都可以定义为虚函数吗？为什么？</p><h3 id="11-main函数执行前后会做什么"><a href="#11-main函数执行前后会做什么" class="headerlink" title="11.main函数执行前后会做什么\"></a>11.main函数执行前后会做什么\</h3><p>main函数执行前：<br>        __start:</p><pre><code class="hljs">　　 :　　 init stack;　　 init heap;　　 open stdin;　　 open stdout;　　 open stderr;　　 :　　 push argv;　　 push argc;　　 call _main;    (调用 main)调用main函数之前，- 创建进程后，把控制权交给程序的入口函数，即为运行时库的某个入口函数。​- glibc的入口函数是_start- msvc(vc 6.0)的是mainCRTStartup- 入口函数对运行库和运行环境进行初始化，包括堆、I/O、线程、全局变量构造- 初始化堆，栈（设置栈指针）- 全局变量、对象和静态变量、对象的空间分配和初始化。- 初始化C/C++库- 参数压栈  argc,argv ,获取环境变量- 打开标准输入，输出、错误流- 注册析构函数，使用atexit注册析构函数（注册时在链表头插入链接，main函数退出也从链表头开始获取链表函数，进行调用）</code></pre><ul><li>设置栈指针  </li><li>初始化static静态和global全局变量，即data段的内容  </li><li>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容</li><li>运行全局构造器，估计是C++中构造函数之类的吧</li><li>将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数</li></ul><p>main函数执行后：</p><ul><li><p>全局对象的析构函数会在main函数之后执行；  </p></li><li><p>可以用_onexit 注册一个函数，它会在main 之后执行;    </p><p>  调用main函数之后，  </p><p>  返回入口函数，进行清理工作  </p><p>  包括全局变量析构、堆销毁、关闭I&#x2F;O  </p><p>  销毁堆内存  </p><p>  关闭标准输入、输出、关闭错误流  </p><p>  调用exit系统API退出进程</p></li></ul><p> 用于注册终止函数</p><h5 id="atexit"><a href="#atexit" class="headerlink" title="atexit()"></a>atexit()</h5><p>int atexit (void (*func) (void) )  </p><p>c库中的atexit()函数，当程序正常中止时，调用指定的func函数。当然，你可以在任何地方注册终止函数，但它会在程序终止的时候被调用。</p><p>（终止函数func不接受任何参数）</p><p>_onexit() </p><h3 id="12-c-内存-分区管理"><a href="#12-c-内存-分区管理" class="headerlink" title="12.c++ 内存 分区管理"></a>12.c++ 内存 分区管理</h3><p><a href="https://blog.csdn.net/weixin_48953972/article/details/121402222">https://blog.csdn.net/weixin_48953972&#x2F;article&#x2F;details&#x2F;121402222</a><br>详见<br><img src="/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/p1.png"></p><p><img src="/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/p2.png"></p><p>栈帧<br>每个函数发生调用时，都会有一块栈空间，这块栈空间称为栈帧。</p><p>栈帧的结构如下：<br><img src="/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/p3.png"><br>这里要注意的是：栈空间是从高地址到低地址分配的。</p><ul><li><p>rbp：基址指针寄存器(reextended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p></li><li><p>rsp：栈指针寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p></li></ul><p>栈帧保存了一个函数调用所需要的维护信息：</p><ol><li>函数的返回地址和参数。  </li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。<br>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li></ol><p>总结一下，当函数A调用函数B时：</p><pre><code class="hljs">1. 将函数入参保存要寄存器中。（在函数A的调用栈中）2. 将函数B的返回地址压入栈，即将callq &lt;B&gt;的下一行指令地址压入栈，然后调用函数B。（在函数A的调用栈中）3. 函数参数入栈。（在函数B的调用栈中）4. 局部变量入栈。（在函数B的调用栈中）5. 执行一些运算指令。（在函数B的调用栈中）6. 将返回结果保存到寄存器eax中。（在函数B的调用栈中）7. 从寄存器eax中获得函数B的返回值。（在函数A的调用栈中）</code></pre><h3 id="13-c-string的构造-析构和赋值函数-拷贝函数"><a href="#13-c-string的构造-析构和赋值函数-拷贝函数" class="headerlink" title="13.c++string的构造,析构和赋值函数,拷贝函数"></a>13.c++string的构造,析构和赋值函数,拷贝函数</h3><pre><code class="hljs">class String &#123;public:    String(const char *str=NULL);//构造函数    String(const String &amp;other);//拷贝构造函数    ~String(void);//析构函数    String&amp; operator=(const String &amp;other);//等号操作符重载    void ShowString();private:    char *m_data;//指针&#125;;String::~String()&#123;    delete[] m_data;//析构函数，释放地址空间&#125;String::String(const char *str)&#123;    if (str==NULL)//当初始化串不存在的时候，为m_data申请    &#123;           m_data = new char[1];           *m_data=&#39;\0&#39;;    &#125;else    &#123;        int length = strlen(str);        m_data = new char[length+1];        strcpy(m_data,str);    &#125;&#125;String::String(const String &amp;other)//拷贝构造函数&#123;    int length = strlen(other.m_data);    m_data = new char[length+1];    strcpy(m_data,other.m_data);&#125;String&amp; String::operator=(const String &amp;other)&#123;    if (this==&amp;other)    &#123;        return *this;    &#125;    delete []m_data;    int length = strlen(other.m_data);    m_data=new char[length+1];    strlen(m_data,other.m_data);    return *this;&#125;</code></pre><h3 id="14-交换函数数值”intintint-amp-int-amp-”"><a href="#14-交换函数数值”intintint-amp-int-amp-”" class="headerlink" title="14.交换函数数值”intintint&amp;int&amp;”"></a>14.交换函数数值”int<em>int</em>int&amp;int&amp;”</h3><ul><li>int a 值传递 c++拷贝数据  </li><li>int *a 地址传递 可以通过地址修改  </li><li>int &amp;a 引用传递 直接将这两个参数传过去 可以修改  </li><li>const int &amp; a 不改变值的引用传递</li></ul><h3 id="15-给定一个链表，和一个数字K返回链表倒数第K个节点的值。后面又基于这个题的思想改进了几个题，如一个链表，如何找到它的中间节点？找它的3-x2F-4节点呢？（这里面有很多的解法，较优的用双指针）"><a href="#15-给定一个链表，和一个数字K返回链表倒数第K个节点的值。后面又基于这个题的思想改进了几个题，如一个链表，如何找到它的中间节点？找它的3-x2F-4节点呢？（这里面有很多的解法，较优的用双指针）" class="headerlink" title="15.给定一个链表，和一个数字K返回链表倒数第K个节点的值。后面又基于这个题的思想改进了几个题，如一个链表，如何找到它的中间节点？找它的3&#x2F;4节点呢？（这里面有很多的解法，较优的用双指针）"></a>15.给定一个链表，和一个数字K返回链表倒数第K个节点的值。后面又基于这个题的思想改进了几个题，如一个链表，如何找到它的中间节点？找它的3&#x2F;4节点呢？（这里面有很多的解法，较优的用双指针）</h3><p>双指针 i走k-1步 j开始走 中间节点 i走一步 j走两步  四分之三 找到中间再来一次</p><h3 id="16-vector-的size-可以等于-capacity-吗？如果vector-存储满了，还能再插入元素吗？为什么？"><a href="#16-vector-的size-可以等于-capacity-吗？如果vector-存储满了，还能再插入元素吗？为什么？" class="headerlink" title="16.vector 的size 可以等于 capacity 吗？如果vector 存储满了，还能再插入元素吗？为什么？"></a>16.vector 的size 可以等于 capacity 吗？如果vector 存储满了，还能再插入元素吗？为什么？</h3><p>不可以 可以 size是当前存的个数 capcity是可以存的</p><h3 id="17-知道哪些排序算法？手写冒泡排序算法，并对冒泡排序进行优化"><a href="#17-知道哪些排序算法？手写冒泡排序算法，并对冒泡排序进行优化" class="headerlink" title="17.知道哪些排序算法？手写冒泡排序算法，并对冒泡排序进行优化"></a>17.知道哪些排序算法？手写冒泡排序算法，并对冒泡排序进行优化</h3><p>&#x2F;&#x2F;第一种 添加flag 设flag&#x3D;0 当发生交换则置为1 检测为0则return<br>&#x2F;&#x2F;第二种 记录上一次交换的位置 此时1~lastpos是无序的<br>&#x2F;&#x2F;第三种 每次向前一个向后一个</p><h3 id="18-快速排序的优化"><a href="#18-快速排序的优化" class="headerlink" title="18. 快速排序的优化"></a>18. 快速排序的优化</h3><p>&#x2F;&#x2F;第一种 序列长度达到一定大小时,使用插入排序</p><pre><code class="hljs">int pivotPos;if (high - low + 1 &lt; 10)&#123;    InsertSort(arr,low,high);    return;&#125;if(low &lt; high)&#123;    pivotPos = Partition(arr,low,high);    QSort(arr,low,pivotPos-1);    QSort(arr,pivotPos+1,high);&#125;//第二种尾递归优化  template &lt;class T&gt;void QSort(T arr[],int low,int high)&#123;    int pivotPos;    if (high - low + 1 &lt; 10)    &#123;        InsertSort(arr,low,high);        return;    &#125;    while(low &lt; high)    &#123;        pivotPos = Partition(arr,low,high);        QSort(arr,low,pivotPos-1);        low = pivotPos + 1;    &#125;&#125;//第三种聚集元素 三元选中的基准 聚集</code></pre><h3 id="19-TCP-和-IP-的区别"><a href="#19-TCP-和-IP-的区别" class="headerlink" title="19.TCP 和 IP 的区别"></a>19.TCP 和 IP 的区别</h3><ul><li>ip是网络层点到点的协议 专注于原机到目标机 使用ip地址作为通讯地址 采用无连接经历交付方式   </li><li>tcp是传输层进程到进程的协议 采用连接交付  套接字为 <h3 id="20-TCP-的特性"><a href="#20-TCP-的特性" class="headerlink" title="20.TCP 的特性"></a>20.TCP 的特性</h3>三次握手 四次挥手 全双工 可靠 的 传输层协议</li></ul><h3 id="21-如何在一万个字符串中查找某一个字符串，说出算法思路。"><a href="#21-如何在一万个字符串中查找某一个字符串，说出算法思路。" class="headerlink" title="21.如何在一万个字符串中查找某一个字符串，说出算法思路。"></a>21.如何在一万个字符串中查找某一个字符串，说出算法思路。</h3><p>kmp字符串匹配算法   求得前缀和后缀 的最大匹配</p><h3 id="22-哈希冲突怎么解决"><a href="#22-哈希冲突怎么解决" class="headerlink" title="22.哈希冲突怎么解决"></a>22.哈希冲突怎么解决</h3><p>十字链表法 开放地址法(线性探测,平方探测,再哈希)</p><h3 id="23-Linux的常用指令。"><a href="#23-Linux的常用指令。" class="headerlink" title="23.Linux的常用指令。"></a>23.Linux的常用指令。</h3><p>查看系统进程:【指令】 top<br>语法： top [必要参数] [选择性参数]<br>功能说明： top指令可以显示当前系统正在执行的进程的相关信息<br>【指令】kill命令<br>语法： kill [必要参数] [选择性参数] [进程号]<br>功能说明： kill指令发送指定的信号到相应进程</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>招聘面试经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客常用内容</title>
    <link href="/2022/03/11/hexo%E5%8F%8A%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99%E5%B8%B8%E7%94%A8/"/>
    <url>/2022/03/11/hexo%E5%8F%8A%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99%E5%B8%B8%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="第一-博客内容管理"><a href="#第一-博客内容管理" class="headerlink" title="第一.博客内容管理"></a>第一.博客内容管理</h2><h3 id="博客架构"><a href="#博客架构" class="headerlink" title="博客架构"></a>博客架构</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">博客:</span><span class="hljs-string">.</span><br><span class="hljs-comment">│</span>  <br><span class="hljs-comment">├─学习笔记</span><br><span class="hljs-comment">│</span>   <span class="hljs-comment">├─算法</span><br><span class="hljs-comment">│</span>   <span class="hljs-comment">├─计算机网络</span><br><span class="hljs-comment">│</span>   <span class="hljs-comment">├─Java项目</span><br><span class="hljs-comment">│</span>   <span class="hljs-comment">└─C</span>++<br><span class="hljs-comment">├─个人博客</span><br><span class="hljs-comment">│</span>   <span class="hljs-comment">├─博客相关</span><br><span class="hljs-comment">│</span>   <span class="hljs-comment">└─招聘面试经历</span><br><span class="hljs-comment">└─毕业设计</span><br>    <span class="hljs-comment">├─环境搭建</span><br>    <span class="hljs-comment">├─A</span><span class="hljs-literal">-</span><span class="hljs-comment">Tune</span><br>    <span class="hljs-comment">├─Tuned</span>    <br>    <span class="hljs-comment">├─HPL</span><br>    <span class="hljs-comment">├─HPCG</span><br>    <span class="hljs-comment">└─结果</span><br></code></pre></td></tr></table></figure><h2 id="第二-语法"><a href="#第二-语法" class="headerlink" title="第二.语法"></a>第二.语法</h2><h3 id="0-开头"><a href="#0-开头" class="headerlink" title="0.开头"></a>0.开头</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">博客常用内容</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-03-11 12:31:54</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hexo博客</span><br><span class="hljs-bullet">-</span> <br><span class="hljs-attr">categories:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">个人博客</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">博客相关</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h3 id="1-空格"><a href="#1-空格" class="headerlink" title="1.空格"></a>1.空格</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">不断行空白格<span class="hljs-meta">&amp;nbsp;测试</span><br>半方大的空白<span class="hljs-meta">&amp;ensp;测试</span><br>全方大的空白<span class="hljs-meta">&amp;emsp;测试</span><br></code></pre></td></tr></table></figure><p>不断行空白格&amp;nbsp;测试<br>半方大的空白&amp;ensp;测试<br>全方大的空白&amp;emsp;测试</p><h3 id="2-图片"><a href="#2-图片" class="headerlink" title="2.图片"></a>2.图片</h3><p><code>图片![](xx.jpg)</code></p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h3><p>第一种 <code>代码</code><br>第二种 <code>~~~代码段~~~</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">代码段<br></code></pre></td></tr></table></figure><h3 id="4-表格"><a href="#4-表格" class="headerlink" title="4.表格"></a>4.表格</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">标题1</span>|<span class="hljs-string">标题2</span>|<br>|<span class="hljs-string">-----</span>|<span class="hljs-string">----</span>|<br>|<span class="hljs-string">内容</span>|<span class="hljs-string">内容</span>|<br></code></pre></td></tr></table></figure><table><thead><tr><th>标题1</th><th>标题2</th></tr></thead><tbody><tr><td>内容</td><td>内容</td></tr></tbody></table><h3 id="5-表情等"><a href="#5-表情等" class="headerlink" title="5.表情等"></a>5.表情等</h3><p>警告 <code>:warning:</code><br>:warning:</p><h2 id="第三-博客使用"><a href="#第三-博客使用" class="headerlink" title="第三.博客使用"></a>第三.博客使用</h2><h3 id="1-新建博客"><a href="#1-新建博客" class="headerlink" title="1.新建博客"></a>1.新建博客</h3><p>在搭建博客的文件夹中git bash here 进入到 Blog&#x2F;source&#x2F;_post文件夹中(_post为默认选项 即发表文章) </p><blockquote><p>可以在source文件夹中创建文件夹 new时加参数 例如草稿箱_draft)</p></blockquote><pre><code class="hljs">hexo new [layout] &lt;title&gt;例如 hexo new &quot;我的博客&quot; hexo new post &quot;我的文章&quot; //就会在/source/_post文件创建名为 我的文章.md的文件hexo new draft &quot;我的草稿&quot; //就会在/source/_draft文件创建名为 我的草稿.md的文件</code></pre><p>其中[layout]为布局  </p><ul><li>创建md文件时可以指定布局</li><li>包括三种布局 page draft post分别为页面,草稿,文章  默认为post  </li><li>在新建文件时，Hexo 会根据 scaffolds 文件夹内相对应的文件（可以理解为模板）来建立md文件</li><li>当创建不同的md文件会在不同的存储路径</li></ul><blockquote><p>注意但不想一个文件显示在页面上时,可以移动到_draft文件夹</p><ul><li>在启动服务器时加上 –draft来查看草稿</li><li>还可以在站点配置文件中把render_drafts设为true 可以通过publish将草稿发布文章或者页面</li></ul></blockquote><pre><code class="hljs">hexo server --drafthexo publish [layout] &lt;title&gt;</code></pre><h3 id="2-博客编写"><a href="#2-博客编写" class="headerlink" title="2.博客编写"></a>2.博客编写</h3><h4 id="1-Front-matter"><a href="#1-Front-matter" class="headerlink" title="(1)Front-matter"></a>(1)Front-matter</h4><p>创建一个文件后可以看到这些,成为Front-matter</p><pre><code class="hljs">---title: hexo博客搭建和使用tags:---</code></pre><p>此处包括一些预定义参数如下</p><pre><code class="hljs">layout  布局  默认为true，如果你不想你的文章被处理，可以设置为falsetitle  标题  标题会显示在最上方居中位置 date  建立日期如果不指定则为默认值-文件创建日期，可以自定义。update  更新日期  如果不指定则为默认值-文件修改后重新生成静态文件的日期。comments  是否开启文章的评论功能 默认值为truetags  标签（不适用于页面page布局）categoreies  分类（不适用于页面page布局）permalink  覆盖文章网址keywords  仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</code></pre><p>举个例子</p><pre><code class="hljs">---title: hexo博客搭建和使用date: 2022-03-22 11:51tags:- 博客搭建categories:- 个人博客- 博客搭建使用---</code></pre><h4 id="2-博客正文编写"><a href="#2-博客正文编写" class="headerlink" title="(2)博客正文编写"></a>(2)博客正文编写</h4><p>使用markdow文法编写博客,保存</p><h3 id="3-博客预览和发布"><a href="#3-博客预览和发布" class="headerlink" title="3.博客预览和发布"></a>3.博客预览和发布</h3><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="(1)基本操作"></a>(1)基本操作</h4><p>一般发布文章或者修改博客后需要这些操作：</p><ul><li>清除缓存</li><li>生成静态文件</li><li>启动服务器</li><li>测试没问题</li><li>部署</li></ul><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="(2)常用命令"></a>(2)常用命令</h4><ul><li>清除缓存：hexo clean</li><li>生成静态文件：hexo generate可简写为 hexo g</li><li>启动服务器：hexo server或者 hexo s  此处默认的端口号为4000 可以使用-p（–port）重设端口,此处使用浏览器浏览localhost:4000可以预览自己的博客</li><li>部署：hexo deploy可简写为hexo d，用于将网站部署到服务器上。将博客托管到GitHub Pages或Gitee Pages 注意:此处可以使用-g（–generate），hexo d -g部署前预先生成静态文件，等同于 hexo g -d</li></ul><p>举个例子</p><pre><code class="hljs"> hexo clean   hexo g  hexo s //此处注意预览完在git bash窗口Ctrl+c关闭,直接关闭浏览器可能会使端口无法释放 hexo d</code></pre>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>博客相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深信服面试</title>
    <link href="/2022/03/11/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/03/11/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="深信服面试问题"><a href="#深信服面试问题" class="headerlink" title="深信服面试问题"></a>深信服面试问题</h1><blockquote><p>22届校招-C&#x2F;C++软件开发工程师（深信服）</p></blockquote><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>2022&#x2F;3&#x2F;8 21:55:46 </p><h4 id="1-自我介绍-2-3mins"><a href="#1-自我介绍-2-3mins" class="headerlink" title="1. 自我介绍  (2-3mins)"></a>1. 自我介绍  (2-3mins)</h4><p>  简单的说一下自己的情况,问了一下课程问题 学过什么 ,主要的学习方向</p><h4 id="2-问项目-15mins"><a href="#2-问项目-15mins" class="headerlink" title="2. 问项目  (15mins)"></a>2. 问项目  (15mins)</h4><ul><li>做过什么项目,负责什么,难点是哪里,具体实现用了那些方法,遇到的问题如何解决的  </li><li>根据简历问一下能力,你说你有XXX能力,怎么体现呢,举了例子  </li><li>深挖简历写到的项目,他会针对某个技术点深挖一下,看你实现的思路过程,实现方法一些很细节的东西,就是实际项目内肯定会遇到,但是只是看书很难get到的点.  <blockquote><p>我说的是一个操作系统硬盘启动实现的项目的内容,列举操作系统启动初始化流程,然后他问我硬盘启动引导盘和非引导盘怎么标定,我回答的是int0x13 到哪个地址 0x7c 还是哪个字作为flag的 ps:记不太清了大致有印象 ,就是实现的时候为了在bochs模拟,肯定是在虚拟软盘和实际测试在硬盘启动他有一个寄存器的跳转地址不一样 .然后问了一下这个第一个区启动512字节的区域只有446字节可以用,代码怎么压缩的,在哪里压缩的.<br>因为简历上还有一个项目 是编译器那部分的  可能面试官不熟悉 他就问了一下具体实现了哪些,包括语法树生成和图着色算法的一些问题</p></blockquote></li></ul><p><strong>ps: 对自己一知半解的项目一定不要胡乱往简历上加,容易踩雷,有一些面试官针对你的项目会问的很细,而且是那种只要自己做了肯定有印象的小点,要是只是看书和copy代码,没有认真读过代码的就真的答不上来,而且就算面试官不熟悉,他一边测评也可以现场搜某个点问你,编译器那面试官就是这么问我的</strong></p><h4 id="3-c-容器的问题-10mins"><a href="#3-c-容器的问题-10mins" class="headerlink" title="3. c++容器的问题(10mins)"></a>3. c++容器的问题(10mins)</h4><ul><li>问了一下红黑树,相关的,本质啊实现啊,然后优缺点</li><li>问了一个简单问题:现在有一篇英语论文 然后分析词频问有什么解决方法<blockquote><p>回答第一个肯定是map 键值和value 然后说还有其他方法吗<br>第二个我回答的是哈希一下 可以用单词哈希所得的数作为搜索索引<br>然后答了个map然后把键值和value ,这样根据出现次数可以直接排词频</p></blockquote></li></ul><p> ps:这里我不是很理解他想问啥,然后就想到啥回答啥,其实就是问一些基础数据结构有没有掌握,能不能根据问题选择数据结构啥的</p><h4 id="4-代码-15mins"><a href="#4-代码-15mins" class="headerlink" title="4.代码(15mins)"></a>4.代码(15mins)</h4><p>现场给了个题,leetcode简单的那种,字符处理,看给的字符串是不是合法的ipv4地址 ,然后让你现场写代码,到时间就停</p><p>这个会的话很简单的,没有任何算法,就是把字符串分割然后看你对ipv4的了解,非法输入都做考虑了吗,什么空串,0开头,夹杂字母,考没考虑到ipv4地址也能是二进制的. 我开始用了正则表达式,但是他说最好别用,然后我又重新写了一下</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>2022&#x2F;3&#x2F;10 16:21:10 </p><h4 id="1-问项目-10mins"><a href="#1-问项目-10mins" class="headerlink" title="1. 问项目  (10mins)"></a>1. 问项目  (10mins)</h4><p>又把项目拿出来问了一下,各个方面各个层次的.没啥好说的了,被问太多了,问麻木了</p><h4 id="2-代码-10mins"><a href="#2-代码-10mins" class="headerlink" title="2. 代码(10mins)"></a>2. 代码(10mins)</h4><p>现场编写找两个有序数组的中位数的代码,leetcode到处是,不重复了</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>招聘面试经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>2022届春招</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
