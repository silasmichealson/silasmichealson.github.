<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vm_ware+CentOS7 网络配置及换源教程</title>
    <link href="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/"/>
    <url>/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="vm-ware-CentOS7-网络配置及换源教程"><a href="#vm-ware-CentOS7-网络配置及换源教程" class="headerlink" title="vm_ware + CentOS7 网络配置及换源教程"></a>vm_ware + CentOS7 网络配置及换源教程</h1><h2 id="0-环境"><a href="#0-环境" class="headerlink" title="0.环境"></a>0.环境</h2><blockquote><p>Windows 10 + vmware 15 + centos 7.9</p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/Windows.jpg"></p><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/vmware.jpg"></p><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net1.jpg"></p><p>如果搭建博客还有问题的小伙伴可以参考我这一篇:<a href="https://www.cnblogs.com/silas041301/p/16172840.html">vmware+centos搭建</a></p><h2 id="1-目标"><a href="#1-目标" class="headerlink" title="1.目标"></a>1.目标</h2><ul><li><input disabled="" type="checkbox"> 实现虚拟机联网 可与本机相互ping通 </li><li><input disabled="" type="checkbox"> 虚拟机 ping 通外网</li><li><input disabled="" type="checkbox"> 更换CentOS yum源为阿里源 </li><li><input disabled="" type="checkbox"> 更换pip3源</li></ul><h2 id="2-实现过程"><a href="#2-实现过程" class="headerlink" title="2.实现过程"></a>2.实现过程</h2><h3 id="0-本机地址-amp-虚拟机网络配置"><a href="#0-本机地址-amp-虚拟机网络配置" class="headerlink" title="(0) 本机地址 &amp; 虚拟机网络配置"></a>(0) 本机地址 &amp; 虚拟机网络配置</h3><blockquote><p>本机地址 10.26.64.244</p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net2.jpg"></p><p>打开虚拟机的编辑 -&gt; 虚拟网络编辑器 -&gt; 记录一些信息</p><blockquote><p>子网地址段 192.168.18.0 <strong>网段很重要,后面的网关和静态ip都需要前三个保持一致</strong></p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net6.jpg"></p><blockquote><p>子网掩码:255.255.255.0 (默认)<br>子网网关:192.168.18.2 (一般默认为x.x.x.2)</p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net5.jpg"></p><blockquote><p>子网的IP地址范围:192.168.18.128 ~ 192.168.18.254 <strong>等会分配静态ip时要在这个之间</strong></p></blockquote><p><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net4.jpg"></p><h3 id="1-CentOS7-网络配置"><a href="#1-CentOS7-网络配置" class="headerlink" title="(1) CentOS7 网络配置"></a>(1) CentOS7 网络配置</h3><h4 id="a-修改系统网卡"><a href="#a-修改系统网卡" class="headerlink" title="a.修改系统网卡"></a>a.修改系统网卡</h4><ol><li><code>ifconfig</code> 查看CentOS 的网卡<br><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net8.jpg"><br>此处显示 网卡为ens33 状态00:0c:29:08:58:a9 即无网络连接</li><li><code>cd /etc/sysconfig/network-scripts</code>进入网络配置文件夹</li><li><code>ls</code> 显示当前文件夹<br><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net9.jpg"></li><li><code>sudo vi ifcfg-ens33</code>此处修改默认网卡的配置文件<strong>对应第一步看到的默认网卡文件</strong><br><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net10.jpg"></li><li>按键<code>a</code>后进入编辑模式,将文件修改(参考下面代码块)</li><li><code>:wq!</code>保存并退出</li><li><code>systemctl restart network.service</code>重启网络服务</li><li>测试一下<code>ping www.baidu.com</code>以及<code>ping 10.26.64.244</code>后面是之前获得的本机ip地址,结果如下,网络配置成功<br><img src="/2022/04/21/vm-ware-CentOS7-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%8D%A2%E6%BA%90%E6%95%99%E7%A8%8B/net11.jpg"></li></ol><ul><li><input checked="" disabled="" type="checkbox"> 实现虚拟机联网 可与本机相互ping通 </li><li><input checked="" disabled="" type="checkbox"> 虚拟机 ping 通外网</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">TYPE</span>=Ethernet<br><span class="hljs-attr">PROXY_METHOD</span>=none<br><span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">BOOTPROTO</span>=static  <span class="hljs-comment">#设置ip为静态#</span><br><span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><br><span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=stable-privacy<br><span class="hljs-attr">NAME</span>=ens33     <span class="hljs-comment">#设定网卡的名称，要跟文件名称对应 #</span><br><span class="hljs-attr">UUID</span>=f5e37a10-<span class="hljs-number">3</span>da9-<span class="hljs-number">47</span>af-<span class="hljs-number">8</span>dbb-<span class="hljs-number">370</span>b7bf24509 <br><span class="hljs-attr">DEVICE</span>=ens33   <span class="hljs-comment">#设定网卡的名称，要跟文件名称对应 #</span><br><span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span>     <span class="hljs-comment">#是否在开机的的时候启动网卡,改为yes# </span><br><br><span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">18.140</span>     <span class="hljs-comment">#IP 地址需要在上面的范围内 必须设置#   </span><br><span class="hljs-attr">GATEWAY</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">18.2</span>      <span class="hljs-comment">#网关地址 在之前的一步中已经获得 必须设置#</span><br><span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>     <span class="hljs-comment">#子网掩码  必须设置# </span><br><span class="hljs-attr">DNS1</span>=<span class="hljs-number">8.8</span>.<span class="hljs-number">8.8</span>  <span class="hljs-comment">#域名服务器 8.8.8.8 114.114.114.114 都可 同样支持多个域名服务器#  </span><br><br><span class="hljs-attr">NETWORK</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">18.129</span>　　   <span class="hljs-comment">#该网段的第一个 IP# 可以不设置</span><br><span class="hljs-attr">BROADCAST</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">18.255</span>　　<span class="hljs-comment">#最后一个同网段的广播地址#  可以不设置</span><br></code></pre></td></tr></table></figure><h3 id="2-对CentOS的下载源-换源"><a href="#2-对CentOS的下载源-换源" class="headerlink" title="(2)对CentOS的下载源 换源"></a>(2)对CentOS的下载源 换源</h3><p>由于系统本身的源服务器在国外,域名解析后的下载和访问速度感人,而国内阿里,网易和清华等镜像源访问速度更快,可以将yum源换为国内源.</p><ol><li>备份yum源配置文件<code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></li><li>下载新的CentOS-Base.repo 到&#x2F;etc&#x2F;yum.repos.d&#x2F; 这里以阿里源为例  <code>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></li><li>yum清理缓存 生成新的缓冲<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">yum clean <span class="hljs-keyword">all</span><br>yum makecache<br></code></pre></td></tr></table></figure></li></ol><ul><li><input checked="" disabled="" type="checkbox"> 更换CentOS yum源为阿里源</li></ul><h3 id="3-对pip3换源"><a href="#3-对pip3换源" class="headerlink" title="(3)对pip3换源"></a>(3)对pip3换源</h3><p>由于网络有时不稳定的原因，使用pip&#x2F;pip3下载会非常慢。如果使用国内镜像服务就完美的解决了下载速度慢的问题</p><ol><li>进入根目录 <code>cd ~</code></li><li>创建文件夹 <code>mkdir .pip</code></li><li>进入文件夹创建文件 <code>cd .pip</code> <code>vim pip.conf</code></li><li>文件内容参考下代码块</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br><span class="hljs-keyword">index</span>-url=https://pypi.tuna.tsinghua.edu.cn/simple<br><span class="hljs-keyword">trusted</span>-host = pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> 更换pip3源</li></ul><h2 id="3-参考博客"><a href="#3-参考博客" class="headerlink" title="3.参考博客"></a>3.参考博客</h2><ol><li><a href="https://blog.csdn.net/weixin_44110998/article/details/104042358">https://blog.csdn.net/weixin_44110998/article/details/104042358</a></li><li><a href="https://blog.csdn.net/akipa11/article/details/81414875">https://blog.csdn.net/akipa11/article/details/81414875</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux系统</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vm_ware虚拟机安装CentOS7教程</title>
    <link href="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/"/>
    <url>/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="VM-Ware虚拟机-CentOS-7-系统安装教程"><a href="#VM-Ware虚拟机-CentOS-7-系统安装教程" class="headerlink" title="VM_Ware虚拟机+CentOS 7 系统安装教程"></a>VM_Ware虚拟机+CentOS 7 系统安装教程</h1><h2 id="0-安装环境"><a href="#0-安装环境" class="headerlink" title="0.安装环境"></a>0.安装环境</h2><blockquote><p>Windows 10 + vmware 15 + centos 7.9</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/Windows.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/vmware.jpg"></p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><h3 id="1-下载CentOS镜像"><a href="#1-下载CentOS镜像" class="headerlink" title="(1)下载CentOS镜像"></a>(1)下载CentOS镜像</h3><p>可以访问<a href="https://mirrors.aliyun.com/centos">阿里云的CentOS镜像网站</a>进行下载</p><h4 id="step1-访问网站"><a href="#step1-访问网站" class="headerlink" title="step1:访问网站"></a>step1:访问网站</h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/1.jpg"></p><h4 id="step2-找到对应版本"><a href="#step2-找到对应版本" class="headerlink" title="step2:找到对应版本"></a>step2:找到对应版本</h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/2.jpg"></p><h4 id="step3-进入文件夹找到isos镜像文件夹"><a href="#step3-进入文件夹找到isos镜像文件夹" class="headerlink" title="step3:进入文件夹找到isos镜像文件夹"></a>step3:进入文件夹找到isos镜像文件夹</h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/3.jpg"></p><h4 id="step4-找到X86-64文件夹"><a href="#step4-找到X86-64文件夹" class="headerlink" title="step4:找到X86_64文件夹"></a>step4:找到X86_64文件夹</h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/4.jpg"></p><h4 id="step5-根据个人需求下载对应的镜像-可以阅读此文件下的0-README-txt文件查看不同版本的区别-readme文件翻译部分放在下面-注意-记住下载的位置-之后安装会使用到"><a href="#step5-根据个人需求下载对应的镜像-可以阅读此文件下的0-README-txt文件查看不同版本的区别-readme文件翻译部分放在下面-注意-记住下载的位置-之后安装会使用到" class="headerlink" title="step5:根据个人需求下载对应的镜像(可以阅读此文件下的0_README.txt文件查看不同版本的区别,readme文件翻译部分放在下面)注意:记住下载的位置,之后安装会使用到"></a>step5:根据个人需求下载对应的镜像(可以阅读此文件下的0_README.txt文件查看不同版本的区别,readme文件翻译部分放在下面)<strong>注意:记住下载的位置,之后安装会使用到</strong></h4><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/5.jpg"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs subunit">CentOS<span class="hljs-string">-7</span>-x86_64-DVD<span class="hljs-string">-1804</span>.iso<br>这个DVD image包含了可以使用下载器下载的所有包。想使用CentOS的小伙伴都可以下载这个image，面向大部分用户。<br> <br>CentOS<span class="hljs-string">-7</span>-x86_64-NetInstall<span class="hljs-string">-1804</span>.iso<br>这是网络安装和救援image。安装人员会询问应该从哪里获取要安装的软件包。如果您有CentOS软件包的本地镜像，则非常有用。<br> <br>CentOS<span class="hljs-string">-7</span>-x86_64-Everything<span class="hljs-string">-1804</span>.iso<br>这个image包含Centos Linux 7完整的软件包，可用于安装或填充本地镜像。此图像需要16GB USB 闪存，因为它太大了（9G）。<br> <br>CentOS<span class="hljs-string">-7</span>-x86_64-LiveGNOME<span class="hljs-string">-1804</span>.iso<br>CentOS<span class="hljs-string">-7</span>-x86_64-LiveKDE<span class="hljs-string">-1804</span>.iso<br>这些images是CentOS Linux 7的Live image。根据名称，它们使用相应的显示管理器。它们专为测试目的和探索CentOS Linux 7环境而设计。除非您选择从Live环境中安装CentOS Linux 7，否则它们不会修改硬盘的内容。请注意，在这种情况下，您无法更改已安装的软件包集。这需要使用yum在已安装的系统中完成。<br> <br>CentOS<span class="hljs-string">-7</span>-x86_64-Minimal<span class="hljs-string">-1804</span>.iso<br>这个image的目的是安装一个非常基本的CentOS Linux 7系统，只需要最少的软件包即可拥有一个功能系统。请将此图像刻录到CD上并启动计算机。系统上将安装一组预先选择的软件包。其他所有东西都需要使用yum安装。此映像安装的软件包集与从完整DVD映像中选择名为“Minimal”的组时安装的软件包相同。<br><br></code></pre></td></tr></table></figure><h2 id="2-系统安装"><a href="#2-系统安装" class="headerlink" title="2.系统安装"></a>2.系统安装</h2><h3 id="1-虚拟机配置"><a href="#1-虚拟机配置" class="headerlink" title="(1)虚拟机配置"></a>(1)虚拟机配置</h3><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos1.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos2.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos3.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos4.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos5.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos6.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos7.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos8.jpg"></p><blockquote><p>此处网络配置 我选择的是使用本机的ip访问外部网络,如果不需要网络或者只在主机和虚拟机通信可以选择对应的选项.而需要独立的ip可以选择桥接模式</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos9.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos10.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos11.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos12.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos13.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos14.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos15.jpg"></p><h3 id="2-虚拟机挂载镜像"><a href="#2-虚拟机挂载镜像" class="headerlink" title="(2)虚拟机挂载镜像"></a>(2)虚拟机挂载镜像</h3><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos16.jpg"></p><blockquote><p>此处使用到之前下载的镜像文件</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos17.jpg"></p><blockquote><p>开启虚拟机则进入安装过程</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos18.jpg"></p><h3 id="3-系统安装及初始化"><a href="#3-系统安装及初始化" class="headerlink" title="(3)系统安装及初始化"></a>(3)系统安装及初始化</h3><blockquote><p>选择第一项 安装即可</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos19.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos20.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos21.jpg"></p><blockquote><p>注意:<strong>此处软件选择,需要图形界面选择gui图形界面,我选择最小安装则无图型界面,只有命令行,如果是初学者还是选择有gui图形界面的安装</strong></p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos22.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos23.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos24.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos25.jpg"></p><blockquote><p>注意:<strong>root密码一定要记住,最好创建一个用户,不要在root下使用(很危险)</strong></p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos26.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos27.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos28.jpg"></p><blockquote><p>重启后系统已经在运行,这里提示登录,由于刚刚已经创建了用户,可以输入用户名,回车后输入密码登录</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos29.jpg"></p><blockquote><p>到这里已经安装完成,使用<code>uname -a</code>指令看一下系统信息,这样就安装成功了</p></blockquote><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos30.jpg"></p><h3 id="4-创建系统快照-出问题可以回溯"><a href="#4-创建系统快照-出问题可以回溯" class="headerlink" title="(4)创建系统快照,出问题可以回溯"></a>(4)创建系统快照,出问题可以回溯</h3><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos31.jpg"></p><p><img src="/2022/04/21/vm-ware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85CentOS7%E6%95%99%E7%A8%8B/centos32.jpg"></p><h2 id="3-借鉴网址"><a href="#3-借鉴网址" class="headerlink" title="3.借鉴网址"></a>3.借鉴网址</h2><ol><li>感兴趣的可以参考<a href="https://www.haah.net/vm-station">虚拟机建站博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/145102034">知乎帖子</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
      <category>环境搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux系统</tag>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A-Tune的centos安装</title>
    <link href="/2022/04/20/A-Tune%E7%9A%84centos%E5%AE%89%E8%A3%85/"/>
    <url>/2022/04/20/A-Tune%E7%9A%84centos%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Tune在CentOS的移植"><a href="#A-Tune在CentOS的移植" class="headerlink" title="A-Tune在CentOS的移植"></a>A-Tune在CentOS的移植</h1><h2 id="第一-安装环境"><a href="#第一-安装环境" class="headerlink" title="第一.安装环境"></a>第一.安装环境</h2><h3 id="vm-ware虚拟机-centos-7-9"><a href="#vm-ware虚拟机-centos-7-9" class="headerlink" title="vm ware虚拟机 + centos 7.9"></a>vm ware虚拟机 + centos 7.9</h3><p><img src="/a1.jpg"></p><h2 id="第二-安装步骤"><a href="#第二-安装步骤" class="headerlink" title="第二.安装步骤"></a>第二.安装步骤</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h3><p>系统应该配置网络,保证可以ping通外网,具体实现借鉴可以我的另一篇博客</p><p>由于CentOS使用的yum源 和 pip源会出现连接问题 ,可以将其换为国内的源</p><h2 id="第三-遇到的问题与解决"><a href="#第三-遇到的问题与解决" class="headerlink" title="第三.遇到的问题与解决"></a>第三.遇到的问题与解决</h2><h2 id="第四-借鉴网址"><a href="#第四-借鉴网址" class="headerlink" title="第四.借鉴网址"></a>第四.借鉴网址</h2>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
      <category>A-Tune</category>
      
    </categories>
    
    
    <tags>
      
      <tag>A-Tune</tag>
      
      <tag>Linux系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客搭建和使用</title>
    <link href="/2022/03/22/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/22/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo与Github-pages-实现静态博客"><a href="#Hexo与Github-pages-实现静态博客" class="headerlink" title="Hexo与Github pages 实现静态博客"></a>Hexo与Github pages 实现静态博客</h1><h2 id="第一-博客搭建"><a href="#第一-博客搭建" class="headerlink" title="第一.博客搭建"></a>第一.博客搭建</h2><h3 id="1-hexo"><a href="#1-hexo" class="headerlink" title="1.hexo"></a>1.hexo</h3><h4 id="1-hexo是什么"><a href="#1-hexo是什么" class="headerlink" title="(1)hexo是什么"></a>(1)hexo是什么</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h4 id="2-hexo安装"><a href="#2-hexo安装" class="headerlink" title="(2)hexo安装"></a>(2)hexo安装</h4><h5 id="a-安装前提"><a href="#a-安装前提" class="headerlink" title="a.安装前提"></a>a.安装前提</h5><p>安装Hexo前，需要先安装下列应用程序：</p><ul><li>Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li>Git</li></ul><p><strong>git 和 node 的安装方法 在后面hexo + github pages给出 着急的小伙伴可以直接从那里开始看</strong></p><h5 id="b-安装-Hexo"><a href="#b-安装-Hexo" class="headerlink" title="b.安装 Hexo"></a>b.安装 Hexo</h5><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre><code class="hljs">$ npm install -g hexo-cli或者$ npm install hexo</code></pre><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><p>npx hexo <command></p></li><li><p>将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo <command>：</p><p> echo ‘PATH&#x3D;”$PATH:.&#x2F;node_modules&#x2F;.bin”‘ &gt;&gt; ~&#x2F;.profile</p></li></ol><h3 id="2-Github-page"><a href="#2-Github-page" class="headerlink" title="2.Github page"></a>2.Github page</h3><h4 id="1-github-page创建"><a href="#1-github-page创建" class="headerlink" title="(1) github page创建"></a>(1) github page创建</h4><p>基本页面的生成  </p><ol><li>首先你需要注册一个 GitHub 账号，并在个人主界面里选择创建一个新的 Repository 。  </li><li>进入页面后，在 Repository name 的位置填写域名，格式是 username.GitHub.io。</li><li>创建成功之后，点击右上角的 Settings找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题</li><li>选择完毕之后 GitHub Pages 就会自动帮你生成好网站，在他跳转的界面点击 Commit changes 按钮，网站就可以访问了。</li><li>在浏览器里输入你的项目名称，比如 brick713.GitHub.io，就可以看到，你刚刚选择的主题的个人网站的页面了。</li></ol><h3 id="3-hexo-Github-page"><a href="#3-hexo-Github-page" class="headerlink" title="3.hexo +　Github page"></a>3.hexo +　Github page</h3><h4 id="1-git"><a href="#1-git" class="headerlink" title="(1).git"></a>(1).git</h4><h5 id="a-git安装"><a href="#a-git安装" class="headerlink" title="a. git安装"></a>a. git安装</h5><ul><li>windows下载安装 <a href="https://git-scm.com/download/win">git</a></li><li>linux下载安装指令<br><code>sudo apt-get install git-core</code> 或者<code>sudo yum install git-core</code></li></ul><h5 id="b-git和github绑定"><a href="#b-git和github绑定" class="headerlink" title="b. git和github绑定"></a>b. git和github绑定</h5><ol><li><p>安装成功后，将 git 与 GitHub 账号绑定，右键打开 Git Bash</p></li><li><p>配置用户名和邮箱<br><code>git config --global user.name &quot;github 用户名&quot;</code><br><code>git config --global user.email &quot;github 注册邮箱&quot;</code></p></li><li><p>生成 ssh 密钥<br><code>ssh-keygen -t rsa -C &quot;github 注册邮箱&quot;</code></p></li><li><p>一般执行上述命令之后，会生成 id_rsa 和 id_rsa.pub 两个文件，前者是我们私有的，而后者则是对外开放的。接着找到生成的 .ssh 的文件夹中id_rsa.pub 密钥，将内容复制,然后打开 GitHub-Settings-Keys 页面，创建一个新的 SSH key，填写 Title 和 Key，Title 可以随意，而 Key 的内容则是我们刚才复制的 id_rsa.pub 中的内容，最后点击 Add SSH key 即可</p></li></ol><h4 id="2-node-js"><a href="#2-node-js" class="headerlink" title="(2).node.js"></a>(2).node.js</h4><h5 id="a-node-js安装"><a href="#a-node-js安装" class="headerlink" title="a. node.js安装"></a>a. node.js安装</h5><ul><li>下载<a href="https://nodejs.org/en/">node.js下载</a></li><li>一直下一步即可</li><li>验证 在命令行输入 node -v可以查看版本</li></ul><h5 id="b-node-js初始化"><a href="#b-node-js初始化" class="headerlink" title="b. node.js初始化"></a>b. node.js初始化</h5><ul><li>在git bash中安装<br><code> npm i hexo-cli -g</code></li><li>选择一个文件夹来放置博客文件,并用如下命令进行初始化并安装必备组件<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在对应文件夹下git bash here<br> hexo init .<br> npm install<br></code></pre></td></tr></table></figure><h5 id="c-初始化后的文件"><a href="#c-初始化后的文件" class="headerlink" title="c.初始化后的文件"></a>c.初始化后的文件</h5></li><li>_config.yml # 网站配置信息</li><li>package.json # 应用程序信息</li><li>scaffolds # 模板文件夹</li><li>source # 存放用户资源 _drafts 草稿箱  _posts 文章</li><li>themes # 主题文件夹</li></ul><h4 id="3-将自己的github网址-替换-config-yml最后的"><a href="#3-将自己的github网址-替换-config-yml最后的" class="headerlink" title="(3) 将自己的github网址 替换 _config.yml最后的"></a>(3) 将自己的github网址 替换 _config.yml最后的</h4><pre><code class="hljs">deploy:  type: git  repo: //此处替换为自己的github的对应仓库网址    例:https://github.com/xxxxx/xxxxx.github.io.git  branch: master</code></pre><h2 id="第二-博客使用"><a href="#第二-博客使用" class="headerlink" title="第二.博客使用"></a>第二.博客使用</h2><h3 id="1-新建博客"><a href="#1-新建博客" class="headerlink" title="1.新建博客"></a>1.新建博客</h3><p>在搭建博客的文件夹中git bash here 进入到 Blog&#x2F;source&#x2F;_post文件夹中(_post为默认选项 即发表文章) </p><blockquote><p>可以在source文件夹中创建文件夹 new时加参数 例如草稿箱_draft)</p></blockquote><pre><code class="hljs">hexo new [layout] &lt;title&gt;例如 hexo new &quot;我的博客&quot; hexo new post &quot;我的文章&quot; //就会在/source/_post文件创建名为 我的文章.md的文件hexo new draft &quot;我的草稿&quot; //就会在/source/_draft文件创建名为 我的草稿.md的文件</code></pre><p>其中[layout]为布局  </p><ul><li>创建md文件时可以指定布局</li><li>包括三种布局 page draft post分别为页面,草稿,文章  默认为post  </li><li>在新建文件时，Hexo 会根据 scaffolds 文件夹内相对应的文件（可以理解为模板）来建立md文件</li><li>当创建不同的md文件会在不同的存储路径</li></ul><blockquote><p>注意但不想一个文件显示在页面上时,可以移动到_draft文件夹</p><ul><li>在启动服务器时加上 –draft来查看草稿</li><li>还可以在站点配置文件中把render_drafts设为true 可以通过publish将草稿发布文章或者页面</li></ul></blockquote><pre><code class="hljs">hexo server --drafthexo publish [layout] &lt;title&gt;</code></pre><h3 id="2-博客编写"><a href="#2-博客编写" class="headerlink" title="2.博客编写"></a>2.博客编写</h3><h4 id="1-Front-matter"><a href="#1-Front-matter" class="headerlink" title="(1)Front-matter"></a>(1)Front-matter</h4><p>创建一个文件后可以看到这些,成为Front-matter</p><pre><code class="hljs">---title: hexo博客搭建和使用tags:---</code></pre><p>此处包括一些预定义参数如下</p><pre><code class="hljs">layout  布局  默认为true，如果你不想你的文章被处理，可以设置为falsetitle  标题  标题会显示在最上方居中位置 date  建立日期如果不指定则为默认值-文件创建日期，可以自定义。update  更新日期  如果不指定则为默认值-文件修改后重新生成静态文件的日期。comments  是否开启文章的评论功能 默认值为truetags  标签（不适用于页面page布局）categoreies  分类（不适用于页面page布局）permalink  覆盖文章网址keywords  仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</code></pre><p>举个例子</p><pre><code class="hljs">---title: hexo博客搭建和使用date: 2022-03-22 11:51tags:- 博客搭建categories:- 个人博客- 博客搭建使用---</code></pre><h4 id="2-博客正文编写"><a href="#2-博客正文编写" class="headerlink" title="(2)博客正文编写"></a>(2)博客正文编写</h4><p>使用markdow文法编写博客,保存<br>markdown语法可以参考这个<a href="https://markdown.com.cn/">markdown官方语法</a></p><h3 id="3-博客预览和发布"><a href="#3-博客预览和发布" class="headerlink" title="3.博客预览和发布"></a>3.博客预览和发布</h3><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="(1)基本操作"></a>(1)基本操作</h4><p>一般发布文章或者修改博客后需要这些操作：</p><ul><li>清除缓存</li><li>生成静态文件</li><li>启动服务器</li><li>测试没问题</li><li>部署</li></ul><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="(2)常用命令"></a>(2)常用命令</h4><ul><li>清除缓存：hexo clean</li><li>生成静态文件：hexo generate可简写为 hexo g</li><li>启动服务器：hexo server或者 hexo s  此处默认的端口号为4000 可以使用-p（–port）重设端口,此处使用浏览器浏览localhost:4000可以预览自己的博客</li><li>部署：hexo deploy可简写为hexo d，用于将网站部署到服务器上。将博客托管到GitHub Pages或Gitee Pages 注意:此处可以使用-g（–generate），hexo d -g部署前预先生成静态文件，等同于 hexo g -d</li></ul><p>举个例子</p><pre><code class="hljs"> hexo clean   hexo g  hexo s //此处注意预览完在git bash窗口Ctrl+c关闭,直接关闭浏览器可能会使端口无法释放 hexo d</code></pre>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>博客搭建使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIDI播放器开发(一)</title>
    <link href="/2022/03/13/MIDI%E6%92%AD%E6%94%BE%E5%99%A8%E5%BC%80%E5%8F%91-%E4%B8%80/"/>
    <url>/2022/03/13/MIDI%E6%92%AD%E6%94%BE%E5%99%A8%E5%BC%80%E5%8F%91-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="MIDI-player-开发流程及问题归纳-一"><a href="#MIDI-player-开发流程及问题归纳-一" class="headerlink" title="MIDI_player 开发流程及问题归纳(一)"></a>MIDI_player 开发流程及问题归纳(一)</h1><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><ul><li>Swing GUI</li><li>网络连接</li><li>将数据传输到I&#x2F;O设备</li><li>JavaSound的API</li></ul><h2 id="第一部分-JavaSound-API"><a href="#第一部分-JavaSound-API" class="headerlink" title="第一部分 JavaSound API"></a>第一部分 JavaSound API</h2><h3 id="1-异常理解"><a href="#1-异常理解" class="headerlink" title="1. 异常理解"></a>1. 异常理解</h3><p>在MusicTest1.java文件编译时出现报错<br>【报错】:  </p><blockquote><p>$ javac MusicTest1.java<br>MusicTest1.java:5: 错误: 未报告的异常错误<br>MidiUnavailableException; 必须对其进行捕获或声明以便抛<br>Sequencer sequencer &#x3D; MidiSystem.getSequencer();<br>1 个错误  </p></blockquote><p>【解决方法】:此处是Java编译器要我们知道调用的方法有风险,使用API帮助文档查看此函数  </p><blockquote><p>public static Sequencer getSequencer()<br>throws MidiUnavailableException获取默认设备Sequencer ，连接到默认设备。<br>返回的Sequencer实例连接到默认的Synthesizer ，如getSynthesizer()所示 。<br>如果没有Synthesizer可用，或默认Synthesizer无法打开，则sequencer连接到默认值Receiver ，由getReceiver()返回。<br>连接是通过检索取得Transmitter从实例Sequencer并设置其Receiver 。 关闭并重新打开音序器将恢复与默认设备的连接。<br>此方法相当于调用getSequencer(true) 。 </p><p>如果系统属性javax.sound.midi.Sequencer已被定义或在文件“sound.properties”中定义，则用于标识默认的音序器。 详情请参考class description 。 </p></blockquote><blockquote><p>结果<br>默认音序器，连接到默认接收器<br>异常<br>MidiUnavailableException -如果序不可由于资源限制，或者没有 Receiver可通过任何安装 MidiDevice ，或无定序器安装在系统中。<br>另请参见：<br>getSequencer(boolean) ， getSynthesizer() ， getReceiver() </p></blockquote><pre><code class="hljs">try&#123; //危险动作&#125;catch(Exception ex)&#123;//尝试恢复&#125;</code></pre><p>在MusicTest1.java文件编译时出现报错<br>【报错】 javac的时候 中文注释报错<br>【解决方法】 第一 chcp 65001<br>第二 javac -encoding UTF-8 xxx.java  </p><h3 id="2-MIDI理解"><a href="#2-MIDI理解" class="headerlink" title="2. MIDI理解"></a>2. MIDI理解</h3><p>查看 MIDI文件夹&#x2F;MiniMiniMusicApp.Java注释</p><blockquote><p>midi文件有音乐的信息,但不具备声音本身,类似乐谱 -&gt; midi装置知道如何读取midi文件并加以播放-&gt; 喇叭发声</p></blockquote><pre><code class="hljs">/* * @Descripttion:  * @version:  * @Author: silas * @Date: 2022-03-10 20:01:45 * @LastEditors: silas * @LastEditTime: 2022-03-11 20:23:27 */import javax.sound.midi.*;//将midi的包import进去//midi文件有音乐的信息,但不具备声音本身,类似乐谱 -&gt; midi装置知道如何读取midi文件并加以播放-&gt; 喇叭发声public class MiniMiniMusicApp &#123;public static void main(String[] args)&#123;    MiniMiniMusicApp mini = new MiniMiniMusicApp();    mini.play();&#125;public void play()&#123;    try&#123;        //获得一个 sequencer 播放装置        Sequencer player = MidiSystem.getSequencer();        //MidiUnavailableException ex 此处getsequencer的异常时        player.open();//打开播放装置        //创建要播放的东西        Sequence seq = new Sequence(Sequence.PPQ, 4);//参数意义未知                //带有乐曲信息的记录        Track track = seq.createTrack();        //乐曲的音乐符等信息        ShortMessage a = new ShortMessage();//Massage描述做什么.MidiEvent描述什么时候做        a.setMessage(144, 1, 44, 100);//发出44分音符        MidiEvent noteon = new MidiEvent(a, 1);//在第一拍启动a这个massage        track.add(noteon);        /*        setMassage(144,1,44,100)        参数1 类型 144表示开启 128表示关闭        参数2 频道 1是吉他 2是Bass         参数3 音符 0~127 的是不同音高        参数4 音道 多大声音0~100        */        ShortMessage b = new ShortMessage();        b.setMessage(128, 1, 44, 100);        MidiEvent noteoff = new MidiEvent(b, 16);        track.add(noteoff);        player.setSequence(seq);//将sequence送到sequencer上        player.start();    &#125;catch(Exception ex)&#123;//此处用ex 父类来检测所有异常        ex.printStackTrace();    &#125;&#125;&#125;</code></pre><p>配合的有几个Mini播放器的实现</p><h2 id="第二部分-GUI"><a href="#第二部分-GUI" class="headerlink" title="第二部分 GUI"></a>第二部分 GUI</h2><h3 id="1-GUI理解"><a href="#1-GUI理解" class="headerlink" title="1. GUI理解"></a>1. GUI理解</h3><h4 id="1-窗口"><a href="#1-窗口" class="headerlink" title="(1)窗口"></a>(1)窗口</h4><pre><code class="hljs">public class SimpeGui1 &#123;/** * @param args */public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    JFrame frame = new JFrame();    JButton button = new JButton(&quot;click me &quot;);    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    frame.getContentPane().add(button);    frame.setSize(300, 300);    frame.setVisible(true);&#125;&#125;</code></pre><h4 id="2-button按键"><a href="#2-button按键" class="headerlink" title="(2)button按键"></a>(2)button按键</h4><pre><code class="hljs">public class SimpleGui1b implements ActionListener&#123;JButton button;/** * @param args */public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    SimpleGui1b gui = new SimpleGui1b();    gui.go();&#125;public void go() &#123;    JFrame frame = new JFrame();    button = new JButton(&quot;click me&quot;);        button.addActionListener(this);//向buttton注册        frame.getContentPane().add(BorderLayout.CENTER,button);      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    frame.setSize(300,300);    frame.setVisible(true);&#125;public void actionPerformed(ActionEvent event) &#123;    button.setText(&quot;i have been clicked&quot;);//实现interface上的方法 按钮会以actionevent对象作为参数来调用此方法    &#125;&#125;</code></pre><h3 id="2-GUI监听鼠标点击button并调用画笔"><a href="#2-GUI监听鼠标点击button并调用画笔" class="headerlink" title="2. GUI监听鼠标点击button并调用画笔"></a>2. GUI监听鼠标点击button并调用画笔</h3><p>创建窗口 -&gt; 创建button -&gt; button监听函数 -&gt; button监听到异常状态则实现方法 -&gt; 将buttton和画笔放在窗口上</p><pre><code class="hljs">public class SimpleGui3c implements ActionListener&#123;/** * @param args */JFrame frame;public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    SimpleGui3c gui3c = new SimpleGui3c();    gui3c.go();&#125;public void go() &#123;    frame = new JFrame();//创建窗口    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//在window关闭的时候结束程序        JButton button = new JButton(&quot;change colors&quot;);//创建按钮    button.addActionListener(this);//为按钮添加监听器 即对此按钮操作时会被检测到        MyDrawPanel1 drawPanel = new MyDrawPanel1();//创建自己的画笔        frame.getContentPane().add(BorderLayout.SOUTH,button);//将创建好的按钮添加到窗口    frame.getContentPane().add(BorderLayout.CENTER,drawPanel);//将创建的画笔添加到窗口        //窗口    //        north    //west  center  east    //        south        frame.setSize(300,300);//设置窗口大小    frame.setVisible(true);//显示窗口哦&#125;public void actionPerformed(ActionEvent event) &#123;    //实现interface上的方法 按钮会以actionevent对象作为参数来调用此方法    frame.repaint();//当点击按钮则新绘制窗口&#125;&#125;class MyDrawPanel1 extends JPanel    //此方法会在重新绘制frame的时候被调用&#123;public void  paintComponent(Graphics g)//实际是一个Graphic 2d对象&#123;    Graphics2D graphics2d = (Graphics2D) g;//将类型转换为2d    int green = (int)(Math.random()*255);    int blue = (int)(Math.random()*255);    int red = (int)(Math.random()*255);        Color startColor = new Color(red,green,blue);        green = (int)(Math.random()*255);    blue = (int)(Math.random()*255);    red = (int)(Math.random()*255);    Color endColor = new Color(red,green,blue);        GradientPaint gradientPaint=new GradientPaint(70, 70, startColor, 150,150,endColor);    //70,70 起点 开始颜色 150,150终点 最后颜色    graphics2d.setPaint(gradientPaint);    //将虚拟的笔刷换渐层    graphics2d.fillOval(70, 70, 100, 100);    //用目前的笔刷填满椭圆形的区域&#125;&#125;</code></pre><h3 id="3-多个按钮和控制器-内部类-接口-的方式实现多button对不同对象的调用修改"><a href="#3-多个按钮和控制器-内部类-接口-的方式实现多button对不同对象的调用修改" class="headerlink" title="3. 多个按钮和控制器 (内部类+接口)的方式实现多button对不同对象的调用修改"></a>3. 多个按钮和控制器 (内部类+接口)的方式实现多button对不同对象的调用修改</h3><pre><code class="hljs">public class twobutton &#123;/** * @param args */JFrame frame;JLabel lable;public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    twobutton twobn = new twobutton();    twobn.go();&#125;public void go() &#123;    frame = new JFrame();//创建窗口    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//在window关闭的时候结束程序        JButton button = new JButton(&quot;change colors&quot;);//创建按钮    button.addActionListener(new colorlisterner());//为按钮添加监听器 即对此按钮操作时会被检测到        JButton labButton = new JButton(&quot;change lable&quot;);    labButton.addActionListener(new lablelistener());        lable = new JLabel(&quot;i am a lable&quot;);    MyDrawPanel drawPanel = new MyDrawPanel();//创建自己的绘图程序        frame.getContentPane().add(BorderLayout.SOUTH,button);//将创建好的按钮添加到窗口    frame.getContentPane().add(BorderLayout.CENTER,drawPanel);//将创建的函数添加到窗口    frame.getContentPane().add(BorderLayout.EAST,labButton);    frame.getContentPane().add(BorderLayout.WEST,lable);    //窗口    //        north    //west  center  east    //        south        frame.setSize(500,500);//设置窗口大小    frame.setVisible(true);//显示窗口哦&#125;//    public void actionPerformed(ActionEvent event) &#123;//        //实现interface上的方法 按钮会以actionevent对象作为参数来调用此方法//        frame.repaint();//当点击按钮则新绘制窗口//    &#125; //     方法一 ://    此处由于两个按钮 ,如果都声明一样的方法  (如下) 则编译器无法分辨 哪个 所以不行的//    public void actionPerformed(ActionEvent event)&#123; fram.repaint()&#125;;//    public void actionPerformed(ActionEvent event)&#123;lable.settext(&quot;new test)&#125;;//    方法二:对两个按钮注册同一个监听接口 辨别来自哪个 ok但是不是面向对象的思想//    public void actionPerformed(ActionEvent event) &#123;//    //实现interface上的方法 按钮会以actionevent对象作为参数来调用此方法//    if(enent.getsource() == coloButton) frame.repaint()//当点击按钮则新绘制窗口//  else lable.setText(&quot;new&quot;);//    &#125; //    方法3:创建不同的actionlistener//    class colorbuttonlistener implements ActionListener//    &#123; public void actionPerformed(ActionEvent event) &#123;&#125;&#125;//    class lablebuttonlistener implements ActionListener//    &#123; public void actionPerformed(ActionEvent event) &#123;&#125;&#125;//这些类无法取到所需的变量//解决方法 : 内部类class colorlisterner implements ActionListener&#123;    public void actionPerformed(ActionEvent event)    &#123;        frame.repaint();    &#125;&#125;class lablelistener implements ActionListener&#123;    public void actionPerformed(ActionEvent event)    &#123;        lable.setText(&quot;ouch&quot;);    &#125;&#125;&#125;class MyDrawPanel extends JPanel    //此方法会在重新绘制frame的时候被调用&#123;public void  paintComponent(Graphics g)//实际是一个Graphic 2d对象&#123;    Graphics2D graphics2d = (Graphics2D) g;//将类型转换为2d    int green = (int)(Math.random()*255);    int blue = (int)(Math.random()*255);    int red = (int)(Math.random()*255);        Color startColor = new Color(red,green,blue);        green = (int)(Math.random()*255);    blue = (int)(Math.random()*255);    red = (int)(Math.random()*255);    Color endColor = new Color(red,green,blue);        GradientPaint gradientPaint=new GradientPaint(70, 70, startColor, 150,150,endColor);    //70,70 起点 开始颜色 150,150终点 最后颜色    graphics2d.setPaint(gradientPaint);    //将虚拟的笔刷换渐层     graphics2d.fillOval(70, 70, 100, 100);    //用目前的笔刷填满椭圆形的区域&#125;&#125;</code></pre><h2 id="第三部分-将GUI部分和MIDI结合起来"><a href="#第三部分-将GUI部分和MIDI结合起来" class="headerlink" title="第三部分 将GUI部分和MIDI结合起来"></a>第三部分 将GUI部分和MIDI结合起来</h2><h3 id="1-实现由MIDI主动驱动GUI随机生成的部件"><a href="#1-实现由MIDI主动驱动GUI随机生成的部件" class="headerlink" title="1.实现由MIDI主动驱动GUI随机生成的部件"></a>1.实现由MIDI主动驱动GUI随机生成的部件</h3><blockquote><p>实现方式:  </p><ul><li><p>MIDI在发声时,传出一个shormassage,而在声音添加的监听器 </p><blockquote><p>sequencer.addControllerEventListener(myDrawPanel,new int[] {127});<br> &#x2F;&#x2F;插入时间编号为127的自定义controllerEvent(176)不作任何事只是报告影评被播放,他的tick 和note on是同时进行 </p></blockquote></li><li><p>会将控制信息传到实现了控制接口的画笔类上  </p><blockquote><p>class MyDarwPanel extends JPanel implements ControllerEventListener  </p></blockquote></li><li><p>绘画类中有实现接口的函数  </p><blockquote><p>public void controlChange(ShortMessage eventMessage) {msg &#x3D; true;repaint();}</p></blockquote></li></ul><p>会实现绘画的调用</p></blockquote><h4 id="最终实现-跟着声音随机画图的MIDIplayer"><a href="#最终实现-跟着声音随机画图的MIDIplayer" class="headerlink" title="最终实现:跟着声音随机画图的MIDIplayer"></a>最终实现:跟着声音随机画图的MIDIplayer</h4><pre><code class="hljs">/** *  */package MIDIPlayer;import javax.sound.midi.*;import java.io.*;import javax.swing.*;import java.awt.*;/** * @author wenlo * */public class MiniMusicPlayer3 &#123;/** * @param args */static JFrame frame = new JFrame(&quot;my first music video&quot;);//创建窗口static MyDarwPanel myDrawPanel;//绘画类public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    MiniMusicPlayer3 miniMusicPlayer3 = new MiniMusicPlayer3();    miniMusicPlayer3.go();&#125;public void setUpGui() &#123;    myDrawPanel = new MyDarwPanel();    //创建绘画类实例    frame.setContentPane(myDrawPanel);    frame.setBounds(30,30,300,300);    frame.setVisible(true);&#125;public void go() &#123;    setUpGui();//初始化gui        try &#123;        Sequencer sequencer=MidiSystem.getSequencer();        sequencer.open();                sequencer.addControllerEventListener(myDrawPanel,new int[] &#123;127&#125;);//声音的contre给 绘画        Sequence sequence =new Sequence(Sequence.PPQ, 4);        Track track =sequence.createTrack();                int r =0;        for(int j = 0 ;j &lt; 60 ; j+=4)        &#123;            r = (int)((Math.random()*50)+1);            track.add(makeEvent(144, 1, r, 100, j));            track.add(makeEvent(176, 1, 127, 0, j));            //插入时间编号为127的自定义controllerEvent(176)不作任何事只是报告影评被播放,他的tick 和note on是同时进行            track.add(makeEvent(128, 1, r, 100, j+2));        &#125;                sequencer.setSequence(sequence);        sequencer.setTempoInBPM(120);        sequencer.start();            &#125; catch (Exception e) &#123;        // TODO: handle exception        e.printStackTrace();    &#125;&#125;public MidiEvent makeEvent(int comd,int chan,int one ,int two,int tick) &#123;//创建声音信息    MidiEvent event=null;    try &#123;        ShortMessage a=new ShortMessage();        a.setMessage(comd,chan,one,two);        event = new MidiEvent(a, tick);    &#125; catch (Exception e) &#123;        // TODO: handle exception    &#125;    return event;&#125;class MyDarwPanel extends JPanel implements ControllerEventListener&#123;//绘制类实现控制接口    boolean msg = false;        public void controlChange(ShortMessage eventMessage) &#123;        msg = true;        repaint();    &#125;    public void paintComponent(Graphics graphics) &#123;        if(msg) &#123;            Graphics2D graphics2d = (Graphics2D) graphics;                        int red = (int) (Math.random()*250);            int green = (int) (Math.random()*250);            int blue = (int) (Math.random()*250);                        graphics.setColor(new Color(red,green,blue));                        int hight = (int)((Math.random()*120)+10);            int width = (int)((Math.random()*120)+10);                        int x = (int)((Math.random()*40)+10);            int y = (int)((Math.random()*40)+10);                        graphics.fillRect(x, y, hight, width);            msg =false;        &#125;    &#125;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Java项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习-滑动窗口</title>
    <link href="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>滑动窗口是一种基于双指针的一种思想，两个指针指向的元素之间形成一个窗口。</p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><p>窗口有两类，一种是固定大小类的窗口，一类是大小动态变化的窗口。</p><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><p>利用滑动窗口获取平滑的数据，如一段连续时间的数据平均值，能够有更好的稳定性，如温度监测。</p><p>什么情况可以用滑动窗口来解决实际问题呢？</p><ul><li>一般给出的数据结构是数组或者字符串</li><li>求取某个子串或者子序列最长最短等最值问题或者求某个目标值时</li><li>该问题本身可以通过暴力求解</li></ul><h2 id="4-算法思想"><a href="#4-算法思想" class="headerlink" title="4.算法思想"></a>4.算法思想</h2><ol><li>在序列中使用双指针中的左右指针技巧，初始化 left &#x3D; right &#x3D; 0，把索引闭区间 [left, right] 称为一个窗口。</li></ol><p><img src="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%BB%91%E5%8A%A8%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81.png"></p><ol start="2"><li>先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的序列符合要求。</li></ol><p><img src="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E7%AA%97%E5%8F%A3%E5%85%83%E7%B4%A0%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6.png"><br>3. 此时，停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的序列不再符合要求。同时，每次增加 left前，都要更新一轮结果。</p><p><img src="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8.png"><br>4. 重复第 2 和第 3 步，直到 right 到达序列的尽头。<br>思路其实很简单：第 2 步相当于在寻找一个可行解，然后第 3 步在优化这个可行解，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><h2 id="5-算法模板"><a href="#5-算法模板" class="headerlink" title="5.算法模板"></a>5.算法模板</h2><h3 id="1-单循环–适用于固定窗口大小"><a href="#1-单循环–适用于固定窗口大小" class="headerlink" title="(1)单循环–适用于固定窗口大小"></a>(1)单循环–适用于固定窗口大小</h3><pre><code class="hljs">def template():# 初始化滑动窗口两端left = right = 0# 序列及序列长度seq, seq_len = xx, xx# 滑动窗口序列slide_win = []# 结果值rst = xxwhile right &lt; seq_len:    slide_win.append(seq[right])    # 还没找到一个可行解    if not avaliable(slide_win):        # 扩大窗口        right += 1    else:        # 找到一个可行解，更新结果值        rst = update()        # 缩小窗口        left += 1</code></pre><h3 id="2-双层循环-–-适用于动态窗口"><a href="#2-双层循环-–-适用于动态窗口" class="headerlink" title="(2)双层循环 – 适用于动态窗口"></a>(2)双层循环 – 适用于动态窗口</h3><pre><code class="hljs">def template():# 初始化滑动窗口两端left = right = 0# 序列及序列长度seq, seq_len = xx, xx# 滑动窗口序列slide_win = []# 结果值rst = xxwhile right &lt; seq_len:    slide_win.append(seq[right])    # 还没找到一个可行解    if not avaliable(slide_win):        # 扩大窗口        right += 1        continue    # 循环更新可行解    while avaliable(slide_win):        # 找到一个可行解，更新结果值        rst = update()        # 缩小窗口        left += 1</code></pre><h2 id="6-实战代码"><a href="#6-实战代码" class="headerlink" title="6.实战代码"></a>6.实战代码</h2><h3 id="1-固定窗口-LC438-找到字符串中所有字母异位词"><a href="#1-固定窗口-LC438-找到字符串中所有字母异位词" class="headerlink" title="(1) 固定窗口 LC438_找到字符串中所有字母异位词"></a>(1) 固定窗口 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">LC438_找到字符串中所有字母异位词</a></h3><pre><code class="hljs">vector&lt;int&gt; findAnagrams(string s, string p) &#123;//窗口:字母和p相同的字串  窗口大小 p的长度//当窗口小于n 则first++//当窗口大于等于n  则second++////异位词即字母出现相同vector&lt;int&gt; ans=vector&lt;int&gt;(26,0);vector&lt;int&gt; ver=vector&lt;int&gt;(26,0);vector&lt;int&gt; res;    for(int i = 0 ;i &lt; p.size();i++)    &#123;        ans[p[i]-&#39;a&#39;]++;    &#125;    for(int i = 0;i &lt;s.size();i++ )    &#123;        ver[s[i]-&#39;a&#39;]++;        if(i &gt;= p.size()) ver[s[i-p.size()]-&#39;a&#39;]--;        if(ans == ver) res.push_back(i-p.size()+1);    &#125;    return res;&#125;</code></pre><h3 id="2-动态窗口-LC76-最小覆盖子串"><a href="#2-动态窗口-LC76-最小覆盖子串" class="headerlink" title="(2) 动态窗口 LC76_最小覆盖子串"></a>(2) 动态窗口 <a href="https://leetcode-cn.com/problems/minimum-window-substring/">LC76_最小覆盖子串</a></h3><pre><code class="hljs">string minWindow(string s, string t)&#123;//窗口:s字串的子串能覆盖住t  窗口大小 至少为t.length()//当窗口小于 t.length() 则first++//当窗口大于等于t.length()  若满足则second++//覆盖即 s的字符出现数 &gt;= p的字符出现数//当使用unordermap 来存储&lt;字符,字符出现次数&gt;string result;if(s.empty()||t.empty()) return result;unordered_map&lt;char,int&gt; map;unordered_map&lt;char,int&gt; window;for(char c:t)&#123;    map[c]++;&#125;int minlength = INT_MAX;int lettercount =0;for(int slow = 0 ,fast =0;fast &lt; s.length();fast++)&#123;    char c =s[fast];    if(map.find(c) != map.end())//若此字符是目标串出现过的字符    &#123;        window[c]++;        if(window[c]&lt;= map[c])        lettercount++;//第一次遇到时 让count++    &#125;    if(lettercount &gt;= t.length())//全部的字符已经覆盖到了    &#123;        while(map.find(s[slow])==map.end() || window[slow]&gt; map[slow])    //slow的字符没在目标串中出现的字母或者字符出现次数多与需要    //在满足基恩本条件下缩小窗口        &#123;            window[s[slow]]--;            slow++;        &#125;        if((fast - slow + 1 )&lt; minlength)        &#123;            minlength = fast-slow+1;            result = s.substr(slow,minlength);        &#125;    &#125;&#125;return result;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习(第二部分)-数组</title>
    <link href="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%95%B0%E7%BB%84/"/>
    <url>/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="第二部分-数据结构-数组"><a href="#第二部分-数据结构-数组" class="headerlink" title="第二部分 数据结构 - 数组"></a>第二部分 数据结构 - 数组</h1><h2 id="一-数组理论基础"><a href="#一-数组理论基础" class="headerlink" title="一. 数组理论基础"></a>一. 数组理论基础</h2><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong>  </p><ul><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的</li><li>正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。数组的元素是不能删的，只能覆盖。<h2 id="二-数组问题举例"><a href="#二-数组问题举例" class="headerlink" title="二. 数组问题举例"></a>二. 数组问题举例</h2></li></ul><h3 id="1-有序数组的查找-–二分法"><a href="#1-有序数组的查找-–二分法" class="headerlink" title="1.有序数组的查找 –二分法"></a>1.有序数组的查找 –二分法</h3><pre><code class="hljs">int binary1(vector&lt;int&gt; &amp;num, int target, int low, int high)&#123;//递归if (high &gt;= low)&#123;    int mid = low + (high - low)/ 2;    if (num.at(mid) == target)        return mid;    else if (num.at(mid) &gt; target)        return binary1(num, target, low, mid - 1);    return binary1(num, target, mid + 1, high);&#125;return -1;&#125;int binary2(vector&lt;int&gt; &amp;num, int target)&#123;int low = 0, high = num.size() - 1;int mid;while (low &lt;= high)&#123;    /* code */    mid = low + (high - low) &gt;&gt; 1;    if (num.at(mid) == target)        return mid;    if (num.at(mid) &gt; target)        high = mid - 1;    else        low = mid + 1;&#125;return -1;&#125;int binary3(vector&lt;int&gt; &amp;num, int target)&#123;int low = 0, high = num.size();while (low &lt; high)&#123;    /* code */    int mid = low + (high - low) &gt;&gt; 1;    if (num.at(mid) == target)        return mid;    if (num.at(mid) &gt; target)        high = mid;    else        low = mid + 1;&#125;return -1;&#125;</code></pre><p>理解二分法对于区间的划分来规定边界情况<br>[low,high]  边界设为 low &lt;&#x3D; high 下一次选取[low,mid-1]和[mid+1,low]<br>[low,high) 边界设为 low&lt;high 下一次选取[low,mid) [mid,high) </p><h3 id="2-移除元素-x2F-插入元素"><a href="#2-移除元素-x2F-插入元素" class="headerlink" title="2.移除元素&#x2F;插入元素"></a>2.移除元素&#x2F;插入元素</h3><p> 数组需要大量的移动数据,在考虑时可以使用两个指针(下标),来记录应当保留(移动的)情况  快慢指针</p><blockquote><p>LeetCode N27_移除元素</p></blockquote><pre><code class="hljs">int removeElement(vector&lt;int&gt;&amp; nums, int val)&#123;int first,second;first = 0;for(second =0 ; second &lt; nums.size();second++)&#123;if(nums.at(second)!=val)nums[first++]=nums[second];&#125;return first;&#125;</code></pre><h3 id="3-通过-长度最小的子树组-理解滑动窗口"><a href="#3-通过-长度最小的子树组-理解滑动窗口" class="headerlink" title="3.通过 长度最小的子树组 理解滑动窗口"></a>3.通过 长度最小的子树组 理解滑动窗口</h3><blockquote><p>理解 滑动窗口<br>(1)滑动窗口内的元素是什么?<br>(2)如何移动滑动窗口起始位置?<br>(3)如何滑动窗口终止位置?</p></blockquote><h4 id="1-滑动窗口算法"><a href="#1-滑动窗口算法" class="headerlink" title="(1) 滑动窗口算法"></a>(1) 滑动窗口算法</h4><p>滑动窗口，顾名思义，就是有一个大小可变的窗口，左右两端方向一致的向前滑动（右端固定，左端滑动；左端固定，右端滑动）。可以想象成队列，一端在push元素，另一端在pop元素</p><h4 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="(2)适用范围"></a>(2)适用范围</h4><ol><li>一般是字符串或者列表</li><li>一般是要求最值（最大长度，最短长度等等）或者子序列</li></ol><h4 id="3-算法模板"><a href="#3-算法模板" class="headerlink" title="(3) 算法模板"></a>(3) 算法模板</h4><pre><code class="hljs">int left = 0,right =0;while(right指针未越界)&#123;  char ch = arr[right++];  //右指针移动，更新窗口  ...    //窗口数据满足条件 对于固定窗口而言，就是窗口的大小&gt;=固定值；对于动态窗口，就是从left出发，窗口不断扩充，第一次满足题意的位置  while(窗口数据满足条件)&#123;      //记录或者更新全局数据      ...            //右指针不动，左指针开始移动一位      char tmp = arr[left++];            //左指针移动，窗口缩小，更新窗口数据      ...  &#125;  //返回结果  ...&#125;</code></pre><h4 id="4-结论"><a href="#4-结论" class="headerlink" title="(4) 结论"></a>(4) 结论</h4><ul><li>滑动窗口算法就是用以解决数组&#x2F;字符串的子元素问题</li><li>滑动窗口算法可以将嵌套的for循环问题，转换为单循环问题，降低时间复杂度</li></ul><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="(5) 实例"></a>(5) 实例</h4><blockquote><p>LeetCode N209_长度最小的子树组</p></blockquote><pre><code class="hljs">int minSubArrayLen1(int target, vector&lt;int&gt;&amp; nums)&#123;int sum,res,len,i,j;res = INT32_MAX;for(i=0;i&lt;nums.size();i++)&#123;    sum = 0;    for(j = i ; j &lt; nums.size();j++)    &#123;        sum+=nums[j];        if(sum&gt;=target)        &#123;            len = j - i +1;            res = (res&lt;len)?res:len;            break;        &#125;    &#125;&#125;res = (res==INT32_MAX)?0:res;return res;&#125;int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums)&#123;//滑动窗口内的元素 ： 和大于等于target的子数组//滑动起点 ： i指针 当出现sum &gt;target 是 sum-=nums[i++]//滑动重点 ： j指针当前指针int res,sum,i,j,len;res=INT32_MAX;sum = 0;len = 0;i=0;for(j=0;j&lt;nums.size();j++)&#123;    sum+=nums.at(j);    while (sum&gt;=target)    &#123;        len = j -i+1;        res =(res&lt;len)?res:len;        sum-=nums.at(i++);        /* code */    &#125;&#125;return res==INT32_MAX?0:res;&#125;</code></pre><h3 id="4-循环情况要理清思路"><a href="#4-循环情况要理清思路" class="headerlink" title="4. 循环情况要理清思路"></a>4. 循环情况要理清思路</h3><blockquote><p>LeetCode N59_螺旋矩阵2 </p></blockquote><pre><code class="hljs">vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;vector&lt;vector&lt;int&gt;&gt; num(n,vector&lt;int&gt; (n,0));int len = n-1;int mid = n/2;int loop = n/2;int offset = 1;int stx,sty,i,j;int count =1;stx=sty=0;for(int k = 0 ; k &lt; loop ;k++)&#123;    i=stx;    j=sty;    //left -&gt; right    for(j = sty ; j &lt; sty + n - offset ;j++ )    &#123;        num[i][j] = count++;    &#125;    //up -&gt; down    for(i = stx; i &lt; stx+n-offset;i++)    &#123;        num[i][j] = count++;    &#125;    //right -&gt; left    for(;j&gt;sty;j--)    &#123;        num[i][j] =count++;    &#125;    for(;i&gt;stx;i--)    &#123;        num[i][j]= count++;    &#125;    stx ++;sty++;    offset+=2;&#125;if(n&amp;0x01)&#123;    num[mid][mid] = count;&#125;return num;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习(第一部分)-性能分析</title>
    <link href="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="算法学习-第一部分"><a href="#算法学习-第一部分" class="headerlink" title="算法学习 (第一部分)"></a>算法学习 (第一部分)</h1><h2 id="第一部分-性能分析"><a href="#第一部分-性能分析" class="headerlink" title="第一部分 性能分析"></a>第一部分 性能分析</h2><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h3><p>  问题计算所需时间同问题规模n的关系,采用大O表示法.</p><blockquote><p>常数阶O(1)-&gt; 对数阶O(log2n)-&gt; 线性阶O(n) -&gt;线性对数阶O(nlog2n)-&gt;平方阶O(n2)-&gt;立方阶O(n3),…，-&gt; k次方阶O(nk)-&gt;指数阶O(2n)。 </p></blockquote><p>随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p><h4 id="1-举个例子"><a href="#1-举个例子" class="headerlink" title="(1).举个例子"></a>(1).举个例子</h4><p>求:x的n次方</p><pre><code class="hljs">int function1(int x,int n)&#123;    int result = 1;    for(int i = 0 ;i &lt;ｎ；ｉ＋＋）    ｛          result *= x;        &#125;    return result;&#125;int function2(int x,int n)&#123;    if(n == 0) return 1;    return function2(x,n-1);&#125;int function3(int x,int n)&#123;    if(n == 0) return 1;    if(n%2 == 1) return function3(x,n/2)*function3(x,n/2)*x;    return function3(x,n/2)*function3(x,n/2);&#125;int function4(int x,int n)&#123;    if(n == 0) return 1;    int t = function4(x,n/2)    if(n%2==1) return t*t*x;    return t*t;&#125;</code></pre><p>可以看到不同的方法可以使软件的时间空间复杂度截然不同</p><h3 id="2-c-的内存管理"><a href="#2-c-的内存管理" class="headerlink" title="2.c++的内存管理"></a>2.c++的内存管理</h3><h4 id="1-理解c-的内存管理"><a href="#1-理解c-的内存管理" class="headerlink" title="(1)理解c++的内存管理"></a>(1)理解c++的内存管理</h4><p><img src="/2022/03/12/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/p1.png"></p><h4 id="2-理解为何需要内存对齐"><a href="#2-理解为何需要内存对齐" class="headerlink" title="(2)理解为何需要内存对齐?"></a>(2)理解为何需要内存对齐?</h4><ul><li>不是所有的硬件平台都允许访问任意内存地址的数据,某些平台只能在一些地址获取特定类型的数据,否则抛出硬件异常,为了同一程序在不同平台运行,需要内存对齐</li><li>对齐内存后虽然会损失一部分空间,可是能极大提升cpu访问内存的速率(具体原因理解cpu是按块读取内存的,对齐使访问更直接)</li></ul><h3 id="3-空间复杂度"><a href="#3-空间复杂度" class="headerlink" title="3.空间复杂度"></a>3.空间复杂度</h3><p>同理 所需空间同问题规模的关系也可以使用大o表示法,注意空间复杂度为O(1)也成为就地执行.一般的我们使用空间来换取时间.</p><h4 id="1-举个例子-1"><a href="#1-举个例子-1" class="headerlink" title="(1) 举个例子"></a>(1) 举个例子</h4><pre><code class="hljs">int feibo1(int n)&#123;//完全的递归if(n&lt;=0) return 0;if(n==1||n==2) return 1;if(n==3) return 2;else return feibo1(n-1)+feibo1(n-2);&#125;int feibo2(int first,int second,int n)&#123;//精简解法 应当理解if(n&lt;=0) return 0;if(n&lt;3) return 1;if(n ==3) return first+second;else return feibo2(second,first+second,n-1);&#125;int feibo3(int n)&#123;//使用数组存储if(n&lt;=0) return 0;if(n==1||n==2) return 1;vector&lt;int&gt; num&#123;1,1&#125;;num.reserve(n+2);vector&lt;int&gt;::iterator it;for(int i = 0; i &lt; n-2 ;i++)&#123;num.push_back(num.at(i)+num.at(i+1));&#125;return num.back();&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++面试问题</title>
    <link href="/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="c-x2F-c-面试笔试"><a href="#c-x2F-c-面试笔试" class="headerlink" title="c&#x2F; c++面试笔试"></a>c&#x2F; c++面试笔试</h1><h3 id="1-c-的知道哪些C语言字符串拷贝的方法"><a href="#1-c-的知道哪些C语言字符串拷贝的方法" class="headerlink" title="1.c++的知道哪些C语言字符串拷贝的方法"></a>1.c++的知道哪些C语言字符串拷贝的方法</h3><h4 id="1-第一个strcpy"><a href="#1-第一个strcpy" class="headerlink" title="(1) 第一个strcpy()"></a>(1) 第一个strcpy()</h4><p>使用头文件：#include &lt;string.h&gt;  </p><pre><code class="hljs">定义：char *strcpy(char *dest, const char *src);参数：destinin：目标字符数组；source：源字符数组；函数说明：  strcpy()会将参数src 字符串拷贝至参数dest 所指的地址。 用于对字符串进行复制，识别到字符串的结束符号‘\0’自动停止返回值：返回参数dest 的字符串起始地址。注意：参数 dest 的内存空间要足够大，否则拷贝可能会造成缓冲溢出。strcpy() 在复制结束后会添加结束符\0，这点和strncpy()不同</code></pre><h4 id="2-memcpy"><a href="#2-memcpy" class="headerlink" title="(2) memcpy()"></a>(2) memcpy()</h4><pre><code class="hljs">使用头文件：C语言：#include &lt;string.h&gt; C++：#include&lt;cstring&gt;定义：void memcpy(void *dest, const void *src, size_t n);参数：destinin：目标地址；source：源地址；n：复制的字节长度。函数说明：memcpy()复制 src 所指的内存数据的 n 个字节到 dest所指的内存地址上。也就是从源地址复制n 个字节到目标地址</code></pre><p>第一个和第二个指针都是void型且第二个指针不能被修改，第三个参数是需要拷贝的内存长度按字节记。</p><p>返回值：返回指向 dest 的指针。返回的指针类型是void。</p><p>注意：</p><p><strong>memcpy()并不限制被复制的数据类型，只是逐字节地进行复制，任何数据类型都可以进行复制，例如字符数组、整型、结构体、类等</strong></p><p>memcpy() 会完整的复制 num个字节，<strong>不会遇到‘\0’而结束</strong>，这点与 strcpy() 不同</p><p>dest 和 src所指的内存空间地址不能重叠</p><p>参数 dest 的内存空间要足够大，起码要大于等于 num个字节</p><p><strong>通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</strong></p><h4 id="3-strncpy"><a href="#3-strncpy" class="headerlink" title="(3)strncpy()"></a>(3)strncpy()</h4><pre><code class="hljs">使用头文件：#include &lt;string.h&gt;定义：char *strncpy(char *dest, const char *src, size_t len);参数：destinin：目标字符数组；source：源字符数组；len：复制的字符串长度。函数说明：strncpy()复制字符串 src 的前 len 个字节到 dest所指的内存地址上。返回值：返回字符串dest</code></pre><p>注意：</p><ul><li><p>strncpy()在复制结束后不会向dest结尾添加’\0’结束符 这个是很重要的一个点，要记住</p></li><li><p>如果source(源字符数组)的长度&gt;复制的字符串数len，则只复制source(源字符数组)的前len个字符，不会自动添加结束符\0 </p></li><li><p>如果source(源字符数组)的长度&lt;复制的字符串数len，则以NULL填充dest(目标字符数组),直到复制完n个字节</p></li><li><p>参数 dest 的内存空间要足够大，起码要大于等于 num个字节</p></li><li><p>在使用strncpy()的时候，拷贝长度最好为strlen(src)+1，以保证最后的结束符\0也能被复制</p><h4 id="3-memmove"><a href="#3-memmove" class="headerlink" title="(3) memmove()"></a>(3) memmove()</h4><p>  使用头文件：#include &lt;string.h&gt;</p><p>  定义：void <em>memmove( void</em> dest, const void* src, size_t count );</p><p>  参数：</p><p>  destinin：目标地址；<br>  source：源地址；<br>  count：复制的字节长度。</p></li></ul><p>函数说明：memmove()复制 src 所指的内存数据的 n 个字节到 dest所指的内存地址上。也就是从源地址复制n 个字节到目标地址。<br><strong>如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。</strong></p><h3 id="2-new-和-malloc的区别"><a href="#2-new-和-malloc的区别" class="headerlink" title="2.new 和 malloc的区别"></a>2.new 和 malloc的区别</h3><h4 id="1-申请的内存所在位置"><a href="#1-申请的内存所在位置" class="headerlink" title="(1). 申请的内存所在位置"></a>(1). 申请的内存所在位置</h4><p> new操作符从自由存储区（free store）上为对象动态分配内存空间，<br> malloc函数从堆上动态分配内存。<br> 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p><p><strong>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</strong></p><h4 id="2-返回类型安全性"><a href="#2-返回类型安全性" class="headerlink" title="(2).返回类型安全性"></a>(2).返回类型安全性</h4><p><strong>new操作符内存分配成功时，返回的是对象类型的指针</strong>，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。<br><strong>而malloc内存分配成功则是返回void 星</strong> ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p><h4 id="3-内存分配失败时的返回值"><a href="#3-内存分配失败时的返回值" class="headerlink" title="(3).内存分配失败时的返回值"></a>(3).内存分配失败时的返回值</h4><p><strong>new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</strong></p><pre><code class="hljs">try&#123;int *a = new int();&#125;catch (bad_alloc)&#123;...&#125;</code></pre><p>如果你想顺便了解下异常基础，可以看<a href="http://www.cnblogs.com/QG-whz/p/5136883.html">http://www.cnblogs.com/QG-whz/p/5136883.html</a> C++ 异常机制分析。</p><h4 id="4-是否需要指定内存大小"><a href="#4-是否需要指定内存大小" class="headerlink" title="(4).是否需要指定内存大小"></a>(4).是否需要指定内存大小</h4><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p><h4 id="5-是否调用构造函数-x2F-析构函数"><a href="#5-是否调用构造函数-x2F-析构函数" class="headerlink" title="(5).是否调用构造函数&#x2F;析构函数"></a>(5).是否调用构造函数&#x2F;析构函数</h4><p>使用new操作符来分配对象内存时会经历三个步骤：</p><pre><code class="hljs">第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。第三部：对象构造完成后，返回一个指向该对象的指针。</code></pre><p>使用delete操作符来释放对象内存时会经历两个步骤：</p><pre><code class="hljs">第一步：调用对象的析构函数。第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。  </code></pre><p>总之来说，<strong>new&#x2F;delete会调用对象的构造函数&#x2F;析构函数以完成对象的构造&#x2F;析构。而malloc则不会。</strong></p><h4 id="6-对数组的处理"><a href="#6-对数组的处理" class="headerlink" title="(6).对数组的处理"></a>(6).对数组的处理</h4><p>new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。</p><ul><li><p>注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p></li><li><p>至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：</p></li></ul><h4 id="7-new与malloc是否可以相互调用"><a href="#7-new与malloc是否可以相互调用" class="headerlink" title="(7).new与malloc是否可以相互调用"></a>(7).new与malloc是否可以相互调用</h4><p>operator new &#x2F;operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new &#x2F;operator delete 的一种简单方式，其他版本也与之类似：</p><h4 id="8-是否可以被重载"><a href="#8-是否可以被重载" class="headerlink" title="(8).是否可以被重载"></a>(8).是否可以被重载</h4><p>opeartor new &#x2F;operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本：而malloc&#x2F;free并不允许重载。</p><h4 id="9-能够直观地重新分配内存"><a href="#9-能够直观地重新分配内存" class="headerlink" title="(9). 能够直观地重新分配内存"></a>(9). 能够直观地重新分配内存</h4><p>使用malloc分配的内存后，如果在使用过程中发现内存不足，<strong>可以使用realloc函数进行内存重新分配实现内存的扩充</strong>。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p><p>new没有这样直观的配套设施来扩充内存。</p><h4 id="10-客户处理内存分配不足"><a href="#10-客户处理内存分配不足" class="headerlink" title="(10). 客户处理内存分配不足"></a>(10). 客户处理内存分配不足</h4><p>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p><h3 id="3-unix-的初始化和启动"><a href="#3-unix-的初始化和启动" class="headerlink" title="3. unix 的初始化和启动"></a>3. unix 的初始化和启动</h3><h4 id="1-unix系统的初始引导过程"><a href="#1-unix系统的初始引导过程" class="headerlink" title="(1)unix系统的初始引导过程"></a>(1)unix系统的初始引导过程</h4><pre><code class="hljs">unix从硬件加电到--&gt;ROM BIOS（检查硬件系统的配置，找到硬盘0号扇区）--&gt;将0号扇区读入内存</code></pre><h4 id="2-unix系统的初始化"><a href="#2-unix系统的初始化" class="headerlink" title="(2)unix系统的初始化"></a>(2)unix系统的初始化</h4><pre><code class="hljs">ROM BIOS --&gt; mboot/pboot --&gt;boot --&gt;stand/unix --&gt;init0 --&gt;init1  init -- RC.sysint -- rc.x --login在/etc/inittab 中获取initdefault值进入默认的运行级Unix的8个运行级0 停止操作系统1 单用户2 多用户3 加网络4 多用户配置环境5固件诊断，关闭所有服务，关机6 重启S/s 安装、root目录外 其他目录不安装，运行系统内部程序，单用户Abc 伪运行级 运行用户自定义出的程序系统的运行级不会发生变化</code></pre><p>&#x2F;etc&#x2F;RC N N为上述1~6</p><ul><li><p>检查修复root文件系统  </p></li><li><p>设置内部时钟</p></li><li><p>清理和安装所有文件系统</p></li><li><p>清理临时文件 &#x2F;tnp和&#x2F;var&#x2F;tmp</p></li><li><p>设置网络端口、接口、路由</p></li><li><p>启动日志文件调度进程syslogd</p></li><li><p>后台作业调度程序cron</p></li><li><p>启动必要的终端服务进程或应用特定的服务进程</p></li><li><p>用户注册程序</p></li></ul><h4 id="3-unix的启动顺序"><a href="#3-unix的启动顺序" class="headerlink" title="(3)unix的启动顺序"></a>(3)unix的启动顺序</h4><p>通过&#x2F;boot&#x2F;vm进行启动 vmlinuz</p><p>init &#x2F;etc&#x2F;inittab</p><p>启动相应的脚本，并且打开终端</p><pre><code class="hljs">rc.sysinitrc.d(里面的脚本）rc.local</code></pre><p>启动login登录界面 login</p><p>在用户登录的时候执行sh脚本的顺序(每次登录的时候都会完全执行的)</p><pre><code class="hljs">/etc/profile.d/file/etc/profile/etc/bashrc/root/.bashrc/root/.bash_profile</code></pre><h3 id="4-linux系统初始化和启动服务"><a href="#4-linux系统初始化和启动服务" class="headerlink" title="4. linux系统初始化和启动服务"></a>4. linux系统初始化和启动服务</h3><p>linux启动服务详见:<a href="https://blog.csdn.net/chinaren0001/article/details/6901454?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.queryctrv2&spm=1001.2101.3001.4242.1&utm_relevant_index=3" title="Linux如何初始化和启动服务">https://blog.csdn.net/chinaren0001/article/details/6901454?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_title~default-0.queryctrv2&amp;spm&#x3D;1001.2101.3001.4242.1&amp;utm_relevant_index&#x3D;3</a><br>Linux 系统启动过程</p><p>linux启动时我们会看到许多启动信息。</p><p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：  </p><pre><code class="hljs">操作系统--&gt; /boot(MBR)--&gt;init进程--&gt;运行级别(在/etc/inittab文件中)--&gt;初始化系统(/etc/RC.d/RC.sysint) --&gt; /etc/rc.d/rc x.d(根据载入的run level值载入对应目录的程序,决定开启哪些服务)--&gt;/sbin/minggetty(启动六个虚拟控制台)--&gt;用户登录系统(login)内核的引导。运行init。系统初始化。建立终端 。用户登录系统。</code></pre><h4 id="1-BIOS–-gt-MBR–-gt-KERNEL–-gt-INIT进程-一切进程的起点"><a href="#1-BIOS–-gt-MBR–-gt-KERNEL–-gt-INIT进程-一切进程的起点" class="headerlink" title="(1) BIOS–&gt;MBR–&gt;KERNEL–&gt;INIT进程(一切进程的起点)"></a>(1) BIOS–&gt;MBR–&gt;KERNEL–&gt;INIT进程(一切进程的起点)</h4><ol><li><p>当 电脑一打开 电源时电脑就会进入BIOS（BIOS的工作主要是检测一些硬件设备）；</p></li><li><p>检测完后会进入MBR也就是boot loader（MBR位于硬盘的第一个扇区总共512bytes，其中前446bytes里面的编码是在选择引导分区也就是决定要由哪个分区来引导）；</p></li><li><p>载入系统的Kernel(核心)，在Kernel里主要是载入电脑设备的驱动程序，以便可以控制电脑上的设备，并且以只读方式来挂载根目录，也就是一 开始只能读取到根目录所对应的那个分区，所以&#x2F;etc、&#x2F;bin、&#x2F;sbin、&#x2F;dev、&#x2F;lib这五个目录必须同根目录在一个分区中；</p></li><li><p>最后启动init这个程序，所以init这个程序的进程编号为1，是Linux中第一个执行的程序；</p></li></ol><p>init这个程序会根据 Run level来执行以下这些程序：</p><pre><code class="hljs">·/etc/rc.d/rc.sysinit;  ·/etc/rc.d/rc 和 etc/rc.d/rc?.d/  ·/etc/rc.d/rc.local  </code></pre><h4 id="2-介绍-x2F-etc-x2F-rc-d-x2F-rc-sysinit-这个程序主要做哪些工作（init初始化流程第二步）"><a href="#2-介绍-x2F-etc-x2F-rc-d-x2F-rc-sysinit-这个程序主要做哪些工作（init初始化流程第二步）" class="headerlink" title="(2) 介绍 &#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit 这个程序主要做哪些工作（init初始化流程第二步）"></a>(2) 介绍 &#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit 这个程序主要做哪些工作（init初始化流程第二步）</h4><ol><li>启动 udev ，也就是启用热插拔的设备，例如：USB，并且也会启动SELinux；  </li><li>会把kernel的参数设定在&#x2F;etc&#x2F;sysctl.conf配置文件里；这个配置文件下下单元详细说明；  </li><li>设定系统时间；  </li><li>载入 keymaps 设定， keymap设定是在定义 键盘，这样电脑开机时才能找到相对应的键盘设定；  </li><li>启用swap这个虚拟内存的分区；  </li><li>设定主机名称，主机名称设定在 &#x2F;etc&#x2F;sysconfig&#x2F;network 配置文件中的 HOSTNAME&#x3D; 项下；  </li><li>检查根目录有没有问题，并且重新挂载成为可读可写的状态；  </li><li>启用RAID磁盘阵列，以及LVM的设备；</li><li>启用磁盘配额的功能，就是限制使用者最多可以使用多少硬盘空间；  </li><li>检查其它的文件系统，并且把它们挂载进来；  </li><li>最后会清除被修改过的locks及PID files，其实就是清除一些开机时的缓存文件，以及一些没有用的信息及文件；</li></ol><h3 id="5-三次握手-和四次挥手"><a href="#5-三次握手-和四次挥手" class="headerlink" title="5.三次握手 和四次挥手"></a>5.三次握手 和四次挥手</h3><p>详解看这个 结合计算机网络 408 教材<br><a href="https://blog.csdn.net/qq_44443986/article/details/115966274?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164644652416781685335366%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164644652416781685335366&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115966274.pc_search_result_control_group&utm_term=tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B&spm=1018.2226.3001.4187" title="三次握手和四次挥手详解">https://blog.csdn.net/qq_44443986&#x2F;article&#x2F;details&#x2F;115966274?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522164644652416781685335366%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id&#x3D;164644652416781685335366&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>top_positive~default-1-115966274.pc_search_result_control_group&amp;utm_term&#x3D;tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B&amp;spm&#x3D;1018.2226.3001.4187</a></p><h3 id="6-操作系统内存管理"><a href="#6-操作系统内存管理" class="headerlink" title="6.操作系统内存管理"></a>6.操作系统内存管理</h3><p>分段 分页 段页式</p><h3 id="7-new-的底层实现"><a href="#7-new-的底层实现" class="headerlink" title="7.new 的底层实现"></a>7.new 的底层实现</h3><p>operator_num malloc </p><h3 id="8-stl的vector-和-map-x2F-set-无序的map怎么排序"><a href="#8-stl的vector-和-map-x2F-set-无序的map怎么排序" class="headerlink" title="8.stl的vector 和 map&#x2F;set 无序的map怎么排序"></a>8.stl的vector 和 map&#x2F;set 无序的map怎么排序</h3><p>key 和 value 对键值和value的排序通过修改compare的函数</p><h3 id="9-多线程-的同步方式-多进程的-通信方式"><a href="#9-多线程-的同步方式-多进程的-通信方式" class="headerlink" title="9. 多线程 的同步方式,多进程的 通信方式"></a>9. 多线程 的同步方式,多进程的 通信方式</h3><h4 id="1-进程间通讯："><a href="#1-进程间通讯：" class="headerlink" title="(1) 进程间通讯："></a>(1) 进程间通讯：</h4><ol><li><p>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p></li><li><p>有名管道 (namedpipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p></li><li><p>高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p></li><li><p>信号量( semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p></li><li><p>消息队列( messagequeue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p></li><li><p>共享内存( sharedmemory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</p></li><li><p>套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p></li></ol><p>注意：临界区则是一种概念，指的是访问公共资源的程序片段，并不是一种通信方式。</p><h4 id="2-线程通讯："><a href="#2-线程通讯：" class="headerlink" title="(2) 线程通讯："></a>(2) 线程通讯：</h4><ol><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。  </li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。    </li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。  </li><li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量  </li><li>信号机制(Signal)： 类似进程间的信号处理</li></ol><p><strong>提问：互斥锁与信号量的区别？</strong><br>答：互斥锁用于线程的互斥，信号量用于线程的同步。这是互斥锁和信号量的根本区别，也就是互斥和同步之间的区别。同时互斥锁的作用域仅仅在于线程，信号量可以作用于线程和进程。</p><h3 id="10-虚函数-虚函数表-虚函数指针"><a href="#10-虚函数-虚函数表-虚函数指针" class="headerlink" title="10 .虚函数  虚函数表 虚函数指针"></a>10 .虚函数  虚函数表 虚函数指针</h3><p>(1)父类的析构函数不是虚函数会怎样?<br>(2)所有的函数都可以定义为虚函数吗？为什么？</p><h3 id="11-main函数执行前后会做什么"><a href="#11-main函数执行前后会做什么" class="headerlink" title="11.main函数执行前后会做什么\"></a>11.main函数执行前后会做什么\</h3><p>main函数执行前：<br>        __start:</p><pre><code class="hljs">　　 :　　 init stack;　　 init heap;　　 open stdin;　　 open stdout;　　 open stderr;　　 :　　 push argv;　　 push argc;　　 call _main;    (调用 main)调用main函数之前，- 创建进程后，把控制权交给程序的入口函数，即为运行时库的某个入口函数。​- glibc的入口函数是_start- msvc(vc 6.0)的是mainCRTStartup- 入口函数对运行库和运行环境进行初始化，包括堆、I/O、线程、全局变量构造- 初始化堆，栈（设置栈指针）- 全局变量、对象和静态变量、对象的空间分配和初始化。- 初始化C/C++库- 参数压栈  argc,argv ,获取环境变量- 打开标准输入，输出、错误流- 注册析构函数，使用atexit注册析构函数（注册时在链表头插入链接，main函数退出也从链表头开始获取链表函数，进行调用）</code></pre><ul><li>设置栈指针  </li><li>初始化static静态和global全局变量，即data段的内容  </li><li>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容</li><li>运行全局构造器，估计是C++中构造函数之类的吧</li><li>将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数</li></ul><p>main函数执行后：</p><ul><li><p>全局对象的析构函数会在main函数之后执行；  </p></li><li><p>可以用_onexit 注册一个函数，它会在main 之后执行;    </p><p>  调用main函数之后，  </p><p>  返回入口函数，进行清理工作  </p><p>  包括全局变量析构、堆销毁、关闭I&#x2F;O  </p><p>  销毁堆内存  </p><p>  关闭标准输入、输出、关闭错误流  </p><p>  调用exit系统API退出进程</p></li></ul><p> 用于注册终止函数</p><h5 id="atexit"><a href="#atexit" class="headerlink" title="atexit()"></a>atexit()</h5><p>int atexit (void (*func) (void) )  </p><p>c库中的atexit()函数，当程序正常中止时，调用指定的func函数。当然，你可以在任何地方注册终止函数，但它会在程序终止的时候被调用。</p><p>（终止函数func不接受任何参数）</p><p>_onexit() </p><h3 id="12-c-内存-分区管理"><a href="#12-c-内存-分区管理" class="headerlink" title="12.c++ 内存 分区管理"></a>12.c++ 内存 分区管理</h3><p><a href="https://blog.csdn.net/weixin_48953972/article/details/121402222">https://blog.csdn.net/weixin_48953972&#x2F;article&#x2F;details&#x2F;121402222</a><br>详见<br><img src="/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/p1.png"></p><p><img src="/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/p2.png"></p><p>栈帧<br>每个函数发生调用时，都会有一块栈空间，这块栈空间称为栈帧。</p><p>栈帧的结构如下：<br><img src="/2022/03/11/C-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/p3.png"><br>这里要注意的是：栈空间是从高地址到低地址分配的。</p><ul><li><p>rbp：基址指针寄存器(reextended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p></li><li><p>rsp：栈指针寄存器，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</p></li></ul><p>栈帧保存了一个函数调用所需要的维护信息：</p><ol><li>函数的返回地址和参数。  </li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。<br>保存的上下文：包括在函数调用前后需要保持不变的寄存器。</li></ol><p>总结一下，当函数A调用函数B时：</p><pre><code class="hljs">1. 将函数入参保存要寄存器中。（在函数A的调用栈中）2. 将函数B的返回地址压入栈，即将callq &lt;B&gt;的下一行指令地址压入栈，然后调用函数B。（在函数A的调用栈中）3. 函数参数入栈。（在函数B的调用栈中）4. 局部变量入栈。（在函数B的调用栈中）5. 执行一些运算指令。（在函数B的调用栈中）6. 将返回结果保存到寄存器eax中。（在函数B的调用栈中）7. 从寄存器eax中获得函数B的返回值。（在函数A的调用栈中）</code></pre><h3 id="13-c-string的构造-析构和赋值函数-拷贝函数"><a href="#13-c-string的构造-析构和赋值函数-拷贝函数" class="headerlink" title="13.c++string的构造,析构和赋值函数,拷贝函数"></a>13.c++string的构造,析构和赋值函数,拷贝函数</h3><pre><code class="hljs">class String &#123;public:    String(const char *str=NULL);//构造函数    String(const String &amp;other);//拷贝构造函数    ~String(void);//析构函数    String&amp; operator=(const String &amp;other);//等号操作符重载    void ShowString();private:    char *m_data;//指针&#125;;String::~String()&#123;    delete[] m_data;//析构函数，释放地址空间&#125;String::String(const char *str)&#123;    if (str==NULL)//当初始化串不存在的时候，为m_data申请    &#123;           m_data = new char[1];           *m_data=&#39;\0&#39;;    &#125;else    &#123;        int length = strlen(str);        m_data = new char[length+1];        strcpy(m_data,str);    &#125;&#125;String::String(const String &amp;other)//拷贝构造函数&#123;    int length = strlen(other.m_data);    m_data = new char[length+1];    strcpy(m_data,other.m_data);&#125;String&amp; String::operator=(const String &amp;other)&#123;    if (this==&amp;other)    &#123;        return *this;    &#125;    delete []m_data;    int length = strlen(other.m_data);    m_data=new char[length+1];    strlen(m_data,other.m_data);    return *this;&#125;</code></pre><h3 id="14-交换函数数值”intintint-amp-int-amp-”"><a href="#14-交换函数数值”intintint-amp-int-amp-”" class="headerlink" title="14.交换函数数值”intintint&amp;int&amp;”"></a>14.交换函数数值”int<em>int</em>int&amp;int&amp;”</h3><ul><li>int a 值传递 c++拷贝数据  </li><li>int *a 地址传递 可以通过地址修改  </li><li>int &amp;a 引用传递 直接将这两个参数传过去 可以修改  </li><li>const int &amp; a 不改变值的引用传递</li></ul><h3 id="15-给定一个链表，和一个数字K返回链表倒数第K个节点的值。后面又基于这个题的思想改进了几个题，如一个链表，如何找到它的中间节点？找它的3-x2F-4节点呢？（这里面有很多的解法，较优的用双指针）"><a href="#15-给定一个链表，和一个数字K返回链表倒数第K个节点的值。后面又基于这个题的思想改进了几个题，如一个链表，如何找到它的中间节点？找它的3-x2F-4节点呢？（这里面有很多的解法，较优的用双指针）" class="headerlink" title="15.给定一个链表，和一个数字K返回链表倒数第K个节点的值。后面又基于这个题的思想改进了几个题，如一个链表，如何找到它的中间节点？找它的3&#x2F;4节点呢？（这里面有很多的解法，较优的用双指针）"></a>15.给定一个链表，和一个数字K返回链表倒数第K个节点的值。后面又基于这个题的思想改进了几个题，如一个链表，如何找到它的中间节点？找它的3&#x2F;4节点呢？（这里面有很多的解法，较优的用双指针）</h3><p>双指针 i走k-1步 j开始走 中间节点 i走一步 j走两步  四分之三 找到中间再来一次</p><h3 id="16-vector-的size-可以等于-capacity-吗？如果vector-存储满了，还能再插入元素吗？为什么？"><a href="#16-vector-的size-可以等于-capacity-吗？如果vector-存储满了，还能再插入元素吗？为什么？" class="headerlink" title="16.vector 的size 可以等于 capacity 吗？如果vector 存储满了，还能再插入元素吗？为什么？"></a>16.vector 的size 可以等于 capacity 吗？如果vector 存储满了，还能再插入元素吗？为什么？</h3><p>不可以 可以 size是当前存的个数 capcity是可以存的</p><h3 id="17-知道哪些排序算法？手写冒泡排序算法，并对冒泡排序进行优化"><a href="#17-知道哪些排序算法？手写冒泡排序算法，并对冒泡排序进行优化" class="headerlink" title="17.知道哪些排序算法？手写冒泡排序算法，并对冒泡排序进行优化"></a>17.知道哪些排序算法？手写冒泡排序算法，并对冒泡排序进行优化</h3><p>&#x2F;&#x2F;第一种 添加flag 设flag&#x3D;0 当发生交换则置为1 检测为0则return<br>&#x2F;&#x2F;第二种 记录上一次交换的位置 此时1~lastpos是无序的<br>&#x2F;&#x2F;第三种 每次向前一个向后一个</p><h3 id="18-快速排序的优化"><a href="#18-快速排序的优化" class="headerlink" title="18. 快速排序的优化"></a>18. 快速排序的优化</h3><p>&#x2F;&#x2F;第一种 序列长度达到一定大小时,使用插入排序</p><pre><code class="hljs">int pivotPos;if (high - low + 1 &lt; 10)&#123;    InsertSort(arr,low,high);    return;&#125;if(low &lt; high)&#123;    pivotPos = Partition(arr,low,high);    QSort(arr,low,pivotPos-1);    QSort(arr,pivotPos+1,high);&#125;//第二种尾递归优化  template &lt;class T&gt;void QSort(T arr[],int low,int high)&#123;    int pivotPos;    if (high - low + 1 &lt; 10)    &#123;        InsertSort(arr,low,high);        return;    &#125;    while(low &lt; high)    &#123;        pivotPos = Partition(arr,low,high);        QSort(arr,low,pivotPos-1);        low = pivotPos + 1;    &#125;&#125;//第三种聚集元素 三元选中的基准 聚集</code></pre><h3 id="19-TCP-和-IP-的区别"><a href="#19-TCP-和-IP-的区别" class="headerlink" title="19.TCP 和 IP 的区别"></a>19.TCP 和 IP 的区别</h3><ul><li>ip是网络层点到点的协议 专注于原机到目标机 使用ip地址作为通讯地址 采用无连接经历交付方式   </li><li>tcp是传输层进程到进程的协议 采用连接交付  套接字为 <h3 id="20-TCP-的特性"><a href="#20-TCP-的特性" class="headerlink" title="20.TCP 的特性"></a>20.TCP 的特性</h3>三次握手 四次挥手 全双工 可靠 的 传输层协议</li></ul><h3 id="21-如何在一万个字符串中查找某一个字符串，说出算法思路。"><a href="#21-如何在一万个字符串中查找某一个字符串，说出算法思路。" class="headerlink" title="21.如何在一万个字符串中查找某一个字符串，说出算法思路。"></a>21.如何在一万个字符串中查找某一个字符串，说出算法思路。</h3><p>kmp字符串匹配算法   求得前缀和后缀 的最大匹配</p><h3 id="22-哈希冲突怎么解决"><a href="#22-哈希冲突怎么解决" class="headerlink" title="22.哈希冲突怎么解决"></a>22.哈希冲突怎么解决</h3><p>十字链表法 开放地址法(线性探测,平方探测,再哈希)</p><h3 id="23-Linux的常用指令。"><a href="#23-Linux的常用指令。" class="headerlink" title="23.Linux的常用指令。"></a>23.Linux的常用指令。</h3><p>查看系统进程:【指令】 top<br>语法： top [必要参数] [选择性参数]<br>功能说明： top指令可以显示当前系统正在执行的进程的相关信息<br>【指令】kill命令<br>语法： kill [必要参数] [选择性参数] [进程号]<br>功能说明： kill指令发送指定的信号到相应进程</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>招聘面试经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深信服面试</title>
    <link href="/2022/03/11/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E9%9D%A2%E8%AF%95/"/>
    <url>/2022/03/11/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="深信服面试问题"><a href="#深信服面试问题" class="headerlink" title="深信服面试问题"></a>深信服面试问题</h1><blockquote><p>22届校招-C&#x2F;C++软件开发工程师（深信服）</p></blockquote><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>2022&#x2F;3&#x2F;8 21:55:46 </p><h4 id="1-自我介绍-2-3mins"><a href="#1-自我介绍-2-3mins" class="headerlink" title="1. 自我介绍  (2-3mins)"></a>1. 自我介绍  (2-3mins)</h4><p>  简单的说一下自己的情况,问了一下课程问题 学过什么 ,主要的学习方向</p><h4 id="2-问项目-15mins"><a href="#2-问项目-15mins" class="headerlink" title="2. 问项目  (15mins)"></a>2. 问项目  (15mins)</h4><ul><li>做过什么项目,负责什么,难点是哪里,具体实现用了那些方法,遇到的问题如何解决的  </li><li>根据简历问一下能力,你说你有XXX能力,怎么体现呢,举了例子  </li><li>深挖简历写到的项目,他会针对某个技术点深挖一下,看你实现的思路过程,实现方法一些很细节的东西,就是实际项目内肯定会遇到,但是只是看书很难get到的点.  <blockquote><p>我说的是一个操作系统硬盘启动实现的项目的内容,列举操作系统启动初始化流程,然后他问我硬盘启动引导盘和非引导盘怎么标定,我回答的是int0x13 到哪个地址 0x7c 还是哪个字作为flag的 ps:记不太清了大致有印象 ,就是实现的时候为了在bochs模拟,肯定是在虚拟软盘和实际测试在硬盘启动他有一个寄存器的跳转地址不一样 .然后问了一下这个第一个区启动512字节的区域只有446字节可以用,代码怎么压缩的,在哪里压缩的.<br>因为简历上还有一个项目 是编译器那部分的  可能面试官不熟悉 他就问了一下具体实现了哪些,包括语法树生成和图着色算法的一些问题</p></blockquote></li></ul><p><strong>ps: 对自己一知半解的项目一定不要胡乱往简历上加,容易踩雷,有一些面试官针对你的项目会问的很细,而且是那种只要自己做了肯定有印象的小点,要是只是看书和copy代码,没有认真读过代码的就真的答不上来,而且就算面试官不熟悉,他一边测评也可以现场搜某个点问你,编译器那面试官就是这么问我的</strong></p><h4 id="3-c-容器的问题-10mins"><a href="#3-c-容器的问题-10mins" class="headerlink" title="3. c++容器的问题(10mins)"></a>3. c++容器的问题(10mins)</h4><ul><li>问了一下红黑树,相关的,本质啊实现啊,然后优缺点</li><li>问了一个简单问题:现在有一篇英语论文 然后分析词频问有什么解决方法<blockquote><p>回答第一个肯定是map 键值和value 然后说还有其他方法吗<br>第二个我回答的是哈希一下 可以用单词哈希所得的数作为搜索索引<br>然后答了个map然后把键值和value ,这样根据出现次数可以直接排词频</p></blockquote></li></ul><p> ps:这里我不是很理解他想问啥,然后就想到啥回答啥,其实就是问一些基础数据结构有没有掌握,能不能根据问题选择数据结构啥的</p><h4 id="4-代码-15mins"><a href="#4-代码-15mins" class="headerlink" title="4.代码(15mins)"></a>4.代码(15mins)</h4><p>现场给了个题,leetcode简单的那种,字符处理,看给的字符串是不是合法的ipv4地址 ,然后让你现场写代码,到时间就停</p><p>这个会的话很简单的,没有任何算法,就是把字符串分割然后看你对ipv4的了解,非法输入都做考虑了吗,什么空串,0开头,夹杂字母,考没考虑到ipv4地址也能是二进制的. 我开始用了正则表达式,但是他说最好别用,然后我又重新写了一下</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>2022&#x2F;3&#x2F;10 16:21:10 </p><h4 id="1-问项目-10mins"><a href="#1-问项目-10mins" class="headerlink" title="1. 问项目  (10mins)"></a>1. 问项目  (10mins)</h4><p>又把项目拿出来问了一下,各个方面各个层次的.没啥好说的了,被问太多了,问麻木了</p><h4 id="2-代码-10mins"><a href="#2-代码-10mins" class="headerlink" title="2. 代码(10mins)"></a>2. 代码(10mins)</h4><p>现场编写找两个有序数组的中位数的代码,leetcode到处是,不重复了</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
      <category>招聘面试经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>2022届春招</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
